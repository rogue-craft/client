SCRIPT  /home/farkasvolgyi.istvan/.vim/plugged/vim-ruby/autoload/rubycomplete.vim
Sourced 1 time
Total time:   0.090782
 Self time:   0.000672

count  total (s)   self (s)
                            " Vim completion script
                            " Language:		Ruby
                            " Maintainer:		Mark Guzman <segfault@hasno.info>
                            " URL:			https://github.com/vim-ruby/vim-ruby
                            " Release Coordinator:	Doug Kearns <dougkearns@gmail.com>
                            " ----------------------------------------------------------------------------
                            "
                            " Ruby IRB/Complete author: Keiju ISHITSUKA(keiju@ishitsuka.com)
                            " ----------------------------------------------------------------------------
                            
                            " {{{ requirement checks
                            
    1              0.000013 function! s:ErrMsg(msg)
                                echohl ErrorMsg
                                echo a:msg
                                echohl None
                            endfunction
                            
    1              0.000011 if !has('ruby')
                                call s:ErrMsg( "Error: Rubycomplete requires vim compiled with +ruby" )
                                call s:ErrMsg( "Error: falling back to syntax completion" )
                                " lets fall back to syntax completion
                                setlocal omnifunc=syntaxcomplete#Complete
                                finish
    1              0.000001 endif
                            
    1              0.000002 if version < 700
                                call s:ErrMsg( "Error: Required vim >= 7.0" )
                                finish
    1              0.000000 endif
                            " }}} requirement checks
                            
                            " {{{ configuration failsafe initialization
    1              0.000004 if !exists("g:rubycomplete_rails")
                                let g:rubycomplete_rails = 0
    1              0.000001 endif
                            
    1              0.000003 if !exists("g:rubycomplete_classes_in_global")
                                let g:rubycomplete_classes_in_global = 0
    1              0.000000 endif
                            
    1              0.000002 if !exists("g:rubycomplete_buffer_loading")
                                let g:rubycomplete_buffer_loading = 0
    1              0.000001 endif
                            
    1              0.000005 if !exists("g:rubycomplete_include_object")
    1              0.000003     let g:rubycomplete_include_object = 0
    1              0.000001 endif
                            
    1              0.000003 if !exists("g:rubycomplete_include_objectspace")
    1              0.000004     let g:rubycomplete_include_objectspace = 0
    1              0.000001 endif
                            " }}} configuration failsafe initialization
                            
                            " {{{ regex patterns
                            
                            " Regex that defines the start-match for the 'end' keyword.
    1              0.000008 let s:end_start_regex =
                                  \ '\C\%(^\s*\|[=,*/%+\-|;{]\|<<\|>>\|:\s\)\s*\zs' .
                                  \ '\<\%(module\|class\|if\|for\|while\|until\|case\|unless\|begin' .
                                  \   '\|\%(\K\k*[!?]\?\s\+\)\=def\):\@!\>' .
                                  \ '\|\%(^\|[^.:@$]\)\@<=\<do:\@!\>'
                            
                            " Regex that defines the middle-match for the 'end' keyword.
    1              0.000005 let s:end_middle_regex = '\<\%(ensure\|else\|\%(\%(^\|;\)\s*\)\@<=\<rescue:\@!\>\|when\|elsif\):\@!\>'
                            
                            " Regex that defines the end-match for the 'end' keyword.
    1              0.000003 let s:end_end_regex = '\%(^\|[^.:@$]\)\@<=\<end:\@!\>'
                            
                            " }}} regex patterns
                            
                            " {{{ vim-side support functions
    1              0.000002 let s:rubycomplete_debug = 0
                            
    1              0.000004 function! s:dprint(msg)
                                if s:rubycomplete_debug == 1
                                    echom a:msg
                                endif
                            endfunction
                            
    1              0.000003 function! s:GetBufferRubyModule(name, ...)
                                if a:0 == 1
                                    let [snum,enum] = s:GetBufferRubyEntity(a:name, "module", a:1)
                                else
                                    let [snum,enum] = s:GetBufferRubyEntity(a:name, "module")
                                endif
                                return snum . '..' . enum
                            endfunction
                            
    1              0.000002 function! s:GetBufferRubyClass(name, ...)
                                if a:0 >= 1
                                    let [snum,enum] = s:GetBufferRubyEntity(a:name, "class", a:1)
                                else
                                    let [snum,enum] = s:GetBufferRubyEntity(a:name, "class")
                                endif
                                return snum . '..' . enum
                            endfunction
                            
    1              0.000002 function! s:GetBufferRubySingletonMethods(name)
                            endfunction
                            
    1              0.000003 function! s:GetBufferRubyEntity( name, type, ... )
                                let lastpos = getpos(".")
                                let lastline = lastpos
                                if (a:0 >= 1)
                                    let lastline = [ 0, a:1, 0, 0 ]
                                    call cursor( a:1, 0 )
                                endif
                            
                                let stopline = 1
                            
                                let crex = '^\s*\<' . a:type . '\>\s*\<' . escape(a:name, '*') . '\>\s*\(<\s*.*\s*\)\?'
                                let [lnum,lcol] = searchpos( crex, 'w' )
                                "let [lnum,lcol] = searchpairpos( crex . '\zs', '', '\(end\|}\)', 'w' )
                            
                                if lnum == 0 && lcol == 0
                                    call cursor(lastpos[1], lastpos[2])
                                    return [0,0]
                                endif
                            
                                let curpos = getpos(".")
                                let [enum,ecol] = searchpairpos( s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'W' )
                                call cursor(lastpos[1], lastpos[2])
                            
                                if lnum > enum
                                    return [0,0]
                                endif
                                " we found a the class def
                                return [lnum,enum]
                            endfunction
                            
    1              0.000001 function! s:IsInClassDef()
                                return s:IsPosInClassDef( line('.') )
                            endfunction
                            
    1              0.000002 function! s:IsPosInClassDef(pos)
                                let [snum,enum] = s:GetBufferRubyEntity( '.*', "class" )
                                let ret = 'nil'
                            
                                if snum < a:pos && a:pos < enum
                                    let ret = snum . '..' . enum
                                endif
                            
                                return ret
                            endfunction
                            
    1              0.000002 function! s:IsInComment(pos)
                                let stack = synstack(a:pos[0], a:pos[1])
                                if !empty(stack)
                                    return synIDattr(stack[0], 'name') =~ 'ruby\%(.*Comment\|Documentation\)'
                                else
                                    return 0
                                endif
                            endfunction
                            
    1              0.000002 function! s:GetRubyVarType(v)
                                let stopline = 1
                                let vtp = ''
                                let curpos = getpos('.')
                                let sstr = '^\s*#\s*@var\s*'.escape(a:v, '*').'\>\s\+[^ \t]\+\s*$'
                                let [lnum,lcol] = searchpos(sstr,'nb',stopline)
                                if lnum != 0 && lcol != 0
                                    call setpos('.',curpos)
                                    let str = getline(lnum)
                                    let vtp = substitute(str,sstr,'\1','')
                                    return vtp
                                endif
                                call setpos('.',curpos)
                                let ctors = '\(now\|new\|open\|get_instance'
                                if exists('g:rubycomplete_rails') && g:rubycomplete_rails == 1 && s:rubycomplete_rails_loaded == 1
                                    let ctors = ctors.'\|find\|create'
                                else
                                endif
                                let ctors = ctors.'\)'
                            
                                let fstr = '=\s*\([^ \t]\+.' . ctors .'\>\|[\[{"''/]\|%[xwQqr][(\[{@]\|[A-Za-z0-9@:\-()\.]\+...\?\|lambda\|&\)'
                                let sstr = ''.escape(a:v, '*').'\>\s*[+\-*/]*'.fstr
                                let pos = searchpos(sstr,'bW')
                                while pos != [0,0] && s:IsInComment(pos)
                                    let pos = searchpos(sstr,'bW')
                                endwhile
                                if pos != [0,0]
                                    let [lnum, col] = pos
                                    let str = matchstr(getline(lnum),fstr,col)
                                    let str = substitute(str,'^=\s*','','')
                            
                                    call setpos('.',pos)
                                    if str == '"' || str == '''' || stridx(tolower(str), '%q[') != -1
                                        return 'String'
                                    elseif str == '[' || stridx(str, '%w[') != -1
                                        return 'Array'
                                    elseif str == '{'
                                        return 'Hash'
                                    elseif str == '/' || str == '%r{'
                                        return 'Regexp'
                                    elseif strlen(str) >= 4 && stridx(str,'..') != -1
                                        return 'Range'
                                    elseif stridx(str, 'lambda') != -1 || str == '&'
                                        return 'Proc'
                                    elseif strlen(str) > 4
                                        let l = stridx(str,'.')
                                        return str[0:l-1]
                                    end
                                    return ''
                                endif
                                call setpos('.',curpos)
                                return ''
                            endfunction
                            
                            "}}} vim-side support functions
                            
                            "{{{ vim-side completion function
    1              0.000002 function! rubycomplete#Init()
                                execute "ruby VimRubyCompletion.preload_rails"
                            endfunction
                            
    1              0.000003 function! rubycomplete#Complete(findstart, base)
                                 "findstart = 1 when we need to get the text length
                                if a:findstart
                                    let line = getline('.')
                                    let idx = col('.')
                                    while idx > 0
                                        let idx -= 1
                                        let c = line[idx-1]
                                        if c =~ '\w'
                                            continue
                                        elseif ! c =~ '\.'
                                            let idx = -1
                                            break
                                        else
                                            break
                                        endif
                                    endwhile
                            
                                    return idx
                                "findstart = 0 when we need to return the list of completions
                                else
                                    let g:rubycomplete_completions = []
                                    execute "ruby VimRubyCompletion.get_completions('" . a:base . "')"
                                    return g:rubycomplete_completions
                                endif
                            endfunction
                            "}}} vim-side completion function
                            
                            "{{{ ruby-side code
    1              0.000002 function! s:DefRuby()
                            ruby << RUBYEOF
                            # {{{ ruby completion
                            
                            begin
                                require 'rubygems' # let's assume this is safe...?
                            rescue Exception
                                #ignore?
                            end
                            class VimRubyCompletion
                            # {{{ constants
                              @@debug = false
                              @@ReservedWords = [
                                    "BEGIN", "END",
                                    "alias", "and",
                                    "begin", "break",
                                    "case", "class",
                                    "def", "defined", "do",
                                    "else", "elsif", "end", "ensure",
                                    "false", "for",
                                    "if", "in",
                                    "module",
                                    "next", "nil", "not",
                                    "or",
                                    "redo", "rescue", "retry", "return",
                                    "self", "super",
                                    "then", "true",
                                    "undef", "unless", "until",
                                    "when", "while",
                                    "yield",
                                  ]
                            
                              @@Operators = [ "%", "&", "*", "**", "+",  "-",  "/",
                                    "<", "<<", "<=", "<=>", "==", "===", "=~", ">", ">=", ">>",
                                    "[]", "[]=", "^", ]
                            # }}} constants
                            
                            # {{{ buffer analysis magic
                              def load_requires
                            
                                custom_paths = VIM::evaluate("get(g:, 'rubycomplete_load_paths', [])")
                            
                                if !custom_paths.empty?
                                  $LOAD_PATH.concat(custom_paths).uniq!
                                end
                            
                                buf = VIM::Buffer.current
                                enum = buf.line_number
                                nums = Range.new( 1, enum )
                                nums.each do |x|
                            
                                  ln = buf[x]
                                  begin
                                    if /.*require_relative\s*(.*)$/.match( ln )
                                      eval( "require %s" % File.expand_path($1) )
                                    elsif /.*require\s*(["'].*?["'])/.match( ln )
                                      eval( "require %s" % $1 )
                                    end
                                  rescue Exception => e
                                    dprint e.inspect
                                  end
                                end
                              end
                            
                              def load_gems
                                fpath = VIM::evaluate("get(g:, 'rubycomplete_gemfile_path', 'Gemfile')")
                                return unless File.file?(fpath) && File.readable?(fpath)
                                want_bundler = VIM::evaluate("get(g:, 'rubycomplete_use_bundler')")
                                parse_file = !want_bundler
                                begin
                                  require 'bundler'
                                  Bundler.setup
                                  Bundler.require
                                rescue Exception
                                  parse_file = true
                                end
                                if parse_file
                                  File.new(fpath).each_line do |line|
                                    begin
                                      require $1 if /\s*gem\s*['"]([^'"]+)/.match(line)
                                    rescue Exception
                                    end
                                  end
                                end
                              end
                            
                              def load_buffer_class(name)
                                dprint "load_buffer_class(%s) START" % name
                                classdef = get_buffer_entity(name, 's:GetBufferRubyClass("%s")')
                                return if classdef == nil
                            
                                pare = /^\s*class\s*(.*)\s*<\s*(.*)\s*\n/.match( classdef )
                                load_buffer_class( $2 ) if pare != nil  && $2 != name # load parent class if needed
                            
                                mixre = /.*\n\s*(include|prepend)\s*(.*)\s*\n/.match( classdef )
                                load_buffer_module( $2 ) if mixre != nil && $2 != name # load mixins if needed
                            
                                begin
                                  eval classdef
                                rescue Exception
                                  VIM::evaluate( "s:ErrMsg( 'Problem loading class \"%s\", was it already completed?' )" % name )
                                end
                                dprint "load_buffer_class(%s) END" % name
                              end
                            
                              def load_buffer_module(name)
                                dprint "load_buffer_module(%s) START" % name
                                classdef = get_buffer_entity(name, 's:GetBufferRubyModule("%s")')
                                return if classdef == nil
                            
                                begin
                                  eval classdef
                                rescue Exception
                                  VIM::evaluate( "s:ErrMsg( 'Problem loading module \"%s\", was it already completed?' )" % name )
                                end
                                dprint "load_buffer_module(%s) END" % name
                              end
                            
                              def get_buffer_entity(name, vimfun)
                                loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
                                return nil if loading_allowed.to_i.zero?
                                return nil if /(\"|\')+/.match( name )
                                buf = VIM::Buffer.current
                                nums = eval( VIM::evaluate( vimfun % name ) )
                                return nil if nums == nil
                                return nil if nums.min == nums.max && nums.min == 0
                            
                                dprint "get_buffer_entity START"
                                visited = []
                                clscnt = 0
                                bufname = VIM::Buffer.current.name
                                classdef = ""
                                cur_line = VIM::Buffer.current.line_number
                                while (nums != nil && !(nums.min == 0 && nums.max == 0) )
                                  dprint "visited: %s" % visited.to_s
                                  break if visited.index( nums )
                                  visited << nums
                            
                                  nums.each do |x|
                                    if x != cur_line
                                      next if x == 0
                                      ln = buf[x]
                                      is_const = false
                                      if /^\s*(module|class|def|include)\s+/.match(ln) || is_const = /^\s*?[A-Z]([A-z]|[1-9])*\s*?[|]{0,2}=\s*?.+\s*?/.match(ln)
                                        clscnt += 1 if /class|module/.match($1)
                                        # We must make sure to load each constant only once to avoid errors
                                        if is_const
                                            ln.gsub!(/\s*?[|]{0,2}=\s*?/, '||=')
                                        end
                                        #dprint "\$1$1
                                        classdef += "%s\n" % ln
                                        classdef += "end\n" if /def\s+/.match(ln)
                                        dprint ln
                                      end
                                    end
                                  end
                            
                                  nm = "%s(::.*)*\", %s, \"" % [ name, nums.last ]
                                  nums = eval( VIM::evaluate( vimfun % nm ) )
                                  dprint "nm: \"%s\"" % nm
                                  dprint "vimfun: %s" % (vimfun % nm)
                                  dprint "got nums: %s" % nums.to_s
                                end
                                if classdef.length > 1
                                    classdef += "end\n"*clscnt
                                    # classdef = "class %s\n%s\nend\n" % [ bufname.gsub( /\/|\\/, "_" ), classdef ]
                                end
                            
                                dprint "get_buffer_entity END"
                                dprint "classdef====start"
                                lns = classdef.split( "\n" )
                                lns.each { |x| dprint x }
                                dprint "classdef====end"
                                return classdef
                              end
                            
                              def get_var_type( receiver )
                                if /(\"|\')+/.match( receiver )
                                  "String"
                                else
                                  VIM::evaluate("s:GetRubyVarType('%s')" % receiver)
                                end
                              end
                            
                              def dprint( txt )
                                print txt if @@debug
                              end
                            
                              def escape_vim_singlequote_string(str)
                                str.to_s.gsub(/'/,"\\'")
                              end
                            
                              def get_buffer_entity_list( type )
                                # this will be a little expensive.
                                loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
                                allow_aggressive_load = VIM::evaluate("exists('g:rubycomplete_classes_in_global') && g:rubycomplete_classes_in_global")
                                return [] if allow_aggressive_load.to_i.zero? || loading_allowed.to_i.zero?
                            
                                buf = VIM::Buffer.current
                                eob = buf.length
                                ret = []
                                rg = 1..eob
                                re = eval( "/^\s*%s\s*([A-Za-z0-9_:-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*/" % type )
                            
                                rg.each do |x|
                                  if re.match( buf[x] )
                                    next if type == "def" && eval( VIM::evaluate("s:IsPosInClassDef(%s)" % x) ) != nil
                                    ret.push $1
                                  end
                                end
                            
                                return ret
                              end
                            
                              def get_buffer_modules
                                return get_buffer_entity_list( "modules" )
                              end
                            
                              def get_buffer_methods
                                return get_buffer_entity_list( "def" )
                              end
                            
                              def get_buffer_classes
                                return get_buffer_entity_list( "class" )
                              end
                            
                              def load_rails
                                allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
                                return if allow_rails.to_i.zero?
                            
                                buf_path = VIM::evaluate('expand("%:p")')
                                file_name = VIM::evaluate('expand("%:t")')
                                vim_dir = VIM::evaluate('getcwd()')
                                file_dir = buf_path.gsub( file_name, '' )
                                file_dir.gsub!( /\\/, "/" )
                                vim_dir.gsub!( /\\/, "/" )
                                vim_dir << "/"
                                dirs = [ vim_dir, file_dir ]
                                sdirs = [ "", "./", "../", "../../", "../../../", "../../../../" ]
                                rails_base = nil
                            
                                dirs.each do |dir|
                                  sdirs.each do |sub|
                                    trail = "%s%s" % [ dir, sub ]
                                    tcfg = "%sconfig" % trail
                            
                                    if File.exists?( tcfg )
                                      rails_base = trail
                                      break
                                    end
                                  end
                                  break if rails_base
                                end
                            
                                return if rails_base == nil
                                $:.push rails_base unless $:.index( rails_base )
                            
                                rails_config = rails_base + "config/"
                                rails_lib = rails_base + "lib/"
                                $:.push rails_config unless $:.index( rails_config )
                                $:.push rails_lib unless $:.index( rails_lib )
                            
                                bootfile = rails_config + "boot.rb"
                                envfile = rails_config + "environment.rb"
                                if File.exists?( bootfile ) && File.exists?( envfile )
                                  begin
                                    require bootfile
                                    require envfile
                                    begin
                                      require 'console_app'
                                      require 'console_with_helpers'
                                    rescue Exception
                                      dprint "Rails 1.1+ Error %s" % $!
                                      # assume 1.0
                                    end
                                    #eval( "Rails::Initializer.run" ) #not necessary?
                                    VIM::command('let s:rubycomplete_rails_loaded = 1')
                                    dprint "rails loaded"
                                  rescue Exception
                                    dprint "Rails Error %s" % $!
                                    VIM::evaluate( "s:ErrMsg('Error loading rails environment')" )
                                  end
                                end
                              end
                            
                              def get_rails_helpers
                                allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
                                rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
                                return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?
                            
                                buf_path = VIM::evaluate('expand("%:p")')
                                buf_path.gsub!( /\\/, "/" )
                                path_elm = buf_path.split( "/" )
                                dprint "buf_path: %s" % buf_path
                                types = [ "app", "db", "lib", "test", "components", "script" ]
                            
                                i = nil
                                ret = []
                                type = nil
                                types.each do |t|
                                  i = path_elm.index( t )
                                  break if i
                                end
                                type = path_elm[i]
                                type.downcase!
                            
                                dprint "type: %s" % type
                                case type
                                  when "app"
                                    i += 1
                                    subtype = path_elm[i]
                                    subtype.downcase!
                            
                                    dprint "subtype: %s" % subtype
                                    case subtype
                                      when "views"
                                        ret += ActionView::Base.instance_methods
                                        ret += ActionView::Base.methods
                                      when "controllers"
                                        ret += ActionController::Base.instance_methods
                                        ret += ActionController::Base.methods
                                      when "models"
                                        ret += ActiveRecord::Base.instance_methods
                                        ret += ActiveRecord::Base.methods
                                    end
                            
                                  when "db"
                                    ret += ActiveRecord::ConnectionAdapters::SchemaStatements.instance_methods
                                    ret += ActiveRecord::ConnectionAdapters::SchemaStatements.methods
                                end
                            
                                return ret
                              end
                            
                              def add_rails_columns( cls )
                                allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
                                rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
                                return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?
                            
                                begin
                                    eval( "#{cls}.establish_connection" )
                                    return [] unless eval( "#{cls}.ancestors.include?(ActiveRecord::Base).to_s" )
                                    col = eval( "#{cls}.column_names" )
                                    return col if col
                                rescue
                                    dprint "add_rails_columns err: (cls: %s) %s" % [ cls, $! ]
                                    return []
                                end
                                return []
                              end
                            
                              def clean_sel(sel, msg)
                                ret = sel.reject{|x|x.nil?}.uniq
                                ret = ret.grep(/^#{Regexp.quote(msg)}/) if msg != nil
                                ret
                              end
                            
                              def get_rails_view_methods
                                allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
                                rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
                                return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?
                            
                                buf_path = VIM::evaluate('expand("%:p")')
                                buf_path.gsub!( /\\/, "/" )
                                pelm = buf_path.split( "/" )
                                idx = pelm.index( "views" )
                            
                                return [] unless idx
                                idx += 1
                            
                                clspl = pelm[idx].camelize.pluralize
                                cls = clspl.singularize
                            
                                ret = []
                                begin
                                  ret += eval( "#{cls}.instance_methods" )
                                  ret += eval( "#{clspl}Helper.instance_methods" )
                                rescue Exception
                                  dprint "Error: Unable to load rails view helpers for %s: %s" % [ cls, $! ]
                                end
                            
                                return ret
                              end
                            # }}} buffer analysis magic
                            
                            # {{{ main completion code
                              def self.preload_rails
                                a = VimRubyCompletion.new
                                if VIM::evaluate("has('nvim')") == 0
                                  require 'thread'
                                  Thread.new(a) do |b|
                                    begin
                                    b.load_rails
                                    rescue
                                    end
                                  end
                                end
                                a.load_rails
                              rescue
                              end
                            
                              def self.get_completions(base)
                                b = VimRubyCompletion.new
                                b.get_completions base
                              end
                            
                              def get_completions(base)
                                loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
                                if loading_allowed.to_i == 1
                                  load_requires
                                  load_rails
                                end
                            
                                want_gems = VIM::evaluate("get(g:, 'rubycomplete_load_gemfile')")
                                load_gems unless want_gems.to_i.zero?
                            
                                input = VIM::Buffer.current.line
                                cpos = VIM::Window.current.cursor[1] - 1
                                input = input[0..cpos]
                                input += base
                                input.sub!(/.*[ \t\n\"\\'`><=;|&{(]/, '') # Readline.basic_word_break_characters
                                input.sub!(/self\./, '')
                                input.sub!(/.*((\.\.[\[(]?)|([\[(]))/, '')
                            
                                dprint 'input %s' % input
                                message = nil
                                receiver = nil
                                methods = []
                                variables = []
                                classes = []
                                constants = []
                            
                                case input
                                  when /^(\/[^\/]*\/)\.([^.]*)$/ # Regexp
                                    receiver = $1
                                    message = Regexp.quote($2)
                                    methods = Regexp.instance_methods(true)
                            
                                  when /^([^\]]*\])\.([^.]*)$/ # Array
                                    receiver = $1
                                    message = Regexp.quote($2)
                                    methods = Array.instance_methods(true)
                            
                                  when /^([^\}]*\})\.([^.]*)$/ # Proc or Hash
                                    receiver = $1
                                    message = Regexp.quote($2)
                                    methods = Proc.instance_methods(true) | Hash.instance_methods(true)
                            
                                  when /^(:[^:.]*)$/ # Symbol
                                    dprint "symbol"
                                    if Symbol.respond_to?(:all_symbols)
                                      receiver = $1
                                      message = $1.sub( /:/, '' )
                                      methods = Symbol.all_symbols.collect{|s| s.id2name}
                                      methods.delete_if { |c| c.match( /'/ ) }
                                    end
                            
                                  when /^::([A-Z][^:\.\(]*)?$/ # Absolute Constant or class methods
                                    dprint "const or cls"
                                    receiver = $1
                                    methods = Object.constants.collect{ |c| c.to_s }.grep(/^#{receiver}/)
                            
                                  when /^(((::)?[A-Z][^:.\(]*)+?)::?([^:.]*)$/ # Constant or class methods
                                    receiver = $1
                                    message = Regexp.quote($4)
                                    dprint "const or cls 2 [recv: \'%s\', msg: \'%s\']" % [ receiver, message ]
                                    load_buffer_class( receiver )
                                    load_buffer_module( receiver )
                                    begin
                                      constants = eval("#{receiver}.constants").collect{ |c| c.to_s }.grep(/^#{message}/)
                                      methods = eval("#{receiver}.methods").collect{ |m| m.to_s }.grep(/^#{message}/)
                                    rescue Exception
                                      dprint "exception: %s" % $!
                                      constants = []
                                      methods = []
                                    end
                            
                                  when /^(:[^:.]+)\.([^.]*)$/ # Symbol
                                    dprint "symbol"
                                    receiver = $1
                                    message = Regexp.quote($2)
                                    methods = Symbol.instance_methods(true)
                            
                                  when /^([0-9_]+(\.[0-9_]+)?(e[0-9]+)?)\.([^.]*)$/ # Numeric
                                    dprint "numeric"
                                    receiver = $1
                                    message = Regexp.quote($4)
                                    begin
                                      methods = eval(receiver).methods
                                    rescue Exception
                                      methods = []
                                    end
                            
                                  when /^(\$[^.]*)$/ #global
                                    dprint "global"
                                    methods = global_variables.grep(Regexp.new(Regexp.quote($1)))
                            
                                  when /^((\.?[^.]+)+?)\.([^.]*)$/ # variable
                                    dprint "variable"
                                    receiver = $1
                                    message = Regexp.quote($3)
                                    load_buffer_class( receiver )
                            
                                    cv = eval("self.class.constants")
                                    vartype = get_var_type( receiver )
                                    dprint "vartype: %s" % vartype
                            
                                    invalid_vartype = ['', "gets"]
                                    if !invalid_vartype.include?(vartype)
                                      load_buffer_class( vartype )
                            
                                      begin
                                        methods = eval("#{vartype}.instance_methods")
                                        variables = eval("#{vartype}.instance_variables")
                                      rescue Exception
                                        dprint "load_buffer_class err: %s" % $!
                                      end
                                    elsif (cv).include?(receiver)
                                      # foo.func and foo is local var.
                                      methods = eval("#{receiver}.methods")
                                      vartype = receiver
                                    elsif /^[A-Z]/ =~ receiver and /\./ !~ receiver
                                      vartype = receiver
                                      # Foo::Bar.func
                                      begin
                                        methods = eval("#{receiver}.methods")
                                      rescue Exception
                                      end
                                    else
                                      # func1.func2
                                      ObjectSpace.each_object(Module){|m|
                                        next if m.name != "IRB::Context" and
                                          /^(IRB|SLex|RubyLex|RubyToken)/ =~ m.name
                                        methods.concat m.instance_methods(false)
                                      }
                                    end
                                    variables += add_rails_columns( "#{vartype}" ) if vartype && !invalid_vartype.include?(vartype)
                            
                                  when /^\(?\s*[A-Za-z0-9:^@.%\/+*\(\)]+\.\.\.?[A-Za-z0-9:^@.%\/+*\(\)]+\s*\)?\.([^.]*)/
                                    message = $1
                                    methods = Range.instance_methods(true)
                            
                                  when /^\.([^.]*)$/ # unknown(maybe String)
                                    message = Regexp.quote($1)
                                    methods = String.instance_methods(true)
                            
                                else
                                  dprint "default/other"
                                  inclass = eval( VIM::evaluate("s:IsInClassDef()") )
                            
                                  if inclass != nil
                                    dprint "inclass"
                                    classdef = "%s\n" % VIM::Buffer.current[ inclass.min ]
                                    found = /^\s*class\s*([A-Za-z0-9_-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*\n$/.match( classdef )
                            
                                    if found != nil
                                      receiver = $1
                                      message = input
                                      load_buffer_class( receiver )
                                      begin
                                        methods = eval( "#{receiver}.instance_methods" )
                                        variables += add_rails_columns( "#{receiver}" )
                                      rescue Exception
                                        found = nil
                                      end
                                    end
                                  end
                            
                                  if inclass == nil || found == nil
                                    dprint "inclass == nil"
                                    methods = get_buffer_methods
                                    methods += get_rails_view_methods
                            
                                    cls_const = Class.constants
                                    constants = cls_const.select { |c| /^[A-Z_-]+$/.match( c ) }
                                    classes = eval("self.class.constants") - constants
                                    classes += get_buffer_classes
                                    classes += get_buffer_modules
                            
                                    include_objectspace = VIM::evaluate("exists('g:rubycomplete_include_objectspace') && g:rubycomplete_include_objectspace")
                                    ObjectSpace.each_object(Class) { |cls| classes << cls.to_s } if include_objectspace == "1"
                                    message = receiver = input
                                  end
                            
                                  methods += get_rails_helpers
                                  methods += Kernel.public_methods
                                end
                            
                                include_object = VIM::evaluate("exists('g:rubycomplete_include_object') && g:rubycomplete_include_object")
                                methods = clean_sel( methods, message )
                                methods = (methods-Object.instance_methods) if include_object == "0"
                                rbcmeth = (VimRubyCompletion.instance_methods-Object.instance_methods) # lets remove those rubycomplete methods
                                methods = (methods-rbcmeth)
                            
                                variables = clean_sel( variables, message )
                                classes = clean_sel( classes, message ) - ["VimRubyCompletion"]
                                constants = clean_sel( constants, message )
                            
                                valid = []
                                valid += methods.collect { |m| { :name => m.to_s, :type => 'm' } }
                                valid += variables.collect { |v| { :name => v.to_s, :type => 'v' } }
                                valid += classes.collect { |c| { :name => c.to_s, :type => 't' } }
                                valid += constants.collect { |d| { :name => d.to_s, :type => 'd' } }
                                valid.sort! { |x,y| x[:name] <=> y[:name] }
                            
                                outp = ""
                            
                                rg = 0..valid.length
                                rg.step(150) do |x|
                                  stpos = 0+x
                                  enpos = 150+x
                                  valid[stpos..enpos].each { |c| outp += "{'word':'%s','item':'%s','kind':'%s'}," % [ c[:name], c[:name], c[:type] ].map{|x|escape_vim_singlequote_string(x)} }
                                  outp.sub!(/,$/, '')
                            
                                  VIM::command("call extend(g:rubycomplete_completions, [%s])" % outp)
                                  outp = ""
                                end
                              end
                            # }}} main completion code
                            
                            end # VimRubyCompletion
                            # }}} ruby completion
                            RUBYEOF
                            endfunction
                            
    1              0.000004 let s:rubycomplete_rails_loaded = 0
                            
    1   0.090133   0.000023 call s:DefRuby()
                            "}}} ruby-side code
                            
                            " vim:tw=78:sw=4:ts=8:et:fdm=marker:ft=vim:norl:

FUNCTION  <SNR>52_is_jump()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim line 54
Called 1 time
Total time:   0.000119
 Self time:   0.000047

count  total (s)   self (s)
                              " Returns 1 if the next character is a closing delimiter.
    1   0.000051   0.000017   let char = s:get_char(0)
    1   0.000060   0.000022   let list = s:get('right_delims') + s:get('quotes_list')
                            
                              " Closing delimiter on the right.
    1              0.000005   if (!a:0 && index(list, char) > -1) || (a:0 && char == a:1)
    1              0.000001     return 1
                              endif
                            
                              " Closing delimiter with space expansion.
                              let nchar = s:get_char(1)
                              if !a:0 && s:get('expand_space') && char == " "
                                if index(list, nchar) > -1
                                  return 2
                                endif
                              elseif a:0 && s:get('expand_space') && nchar == a:1 && char == ' '
                                return 3
                              endif
                            
                              if !s:get('jump_expansion')
                                return 0
                              endif
                            
                              " Closing delimiter with CR expansion.
                              let uchar = matchstr(getline(line('.') + 1), '^\s*\zs\S')
                              if !a:0 && s:get('expand_cr') && char == ""
                                if index(list, uchar) > -1
                                  return 4
                                endif
                              elseif a:0 && s:get('expand_cr') && uchar == a:1
                                return 5
                              endif
                              return 0

FUNCTION  <SNR>120_map_keys()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim line 198
Called 29 times
Total time:   0.016377
 Self time:   0.016377

count  total (s)   self (s)
   29              0.000192   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
   29              0.000059   if bidx_mode > 0
   29              0.000043     if bidx_mode == 1
  290              0.000669       for i in range(1, 9)
  261              0.012516         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-1)
  290              0.000481       endfor
                                else
                                  for i in range(11, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-11)
                                  endfor
   29              0.000031     endif
   29              0.000920     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
   29              0.000842     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
   29              0.000037   endif

FUNCTION  gutentags#add_job()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 351
Called 4 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
    4              0.000132     call add(s:update_in_progress[a:module], [a:tags_file, a:data])

FUNCTION  <SNR>111_reset_untracked_cache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 284
Called 4 times
Total time:   0.001085
 Self time:   0.000844

count  total (s)   self (s)
                              " shellcmdpost - whether function was called as a result of ShellCmdPost hook
    4              0.000022   if !g:airline#init#vim_async && !has('nvim')
                                if a:shellcmdpost
                                  " Clear cache only if there was no error or the script uses an
                                  " asynchronous interface. Otherwise, cache clearing would overwrite
                                  " v:shell_error with a system() call inside get_*_untracked.
                                  if v:shell_error
                                    return
                                  endif
                                endif
    4              0.000003   endif
                            
    4              0.000143   let file = expand("%:p")
   12              0.000123   for vcs in keys(s:vcs_config)
                                " Dump the value of the cache for the current file. Partially mitigates the
                                " issue of cache invalidation happening before a call to
                                " s:update_untracked()
    8   0.000582   0.000341     call airline#extensions#branch#update_untracked_config(file, vcs)
    8              0.000072     let s:vcs_config[vcs].untracked = {}
   12              0.000018   endfor

FUNCTION  <SNR>146_AfterEndKeyword()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 575
Called 4 times
Total time:   0.000549
 Self time:   0.000218

count  total (s)   self (s)
    4              0.000014   let info = a:pline_info
                              " If the previous line ended with an "end", match that "end"s beginning's
                              " indent.
    4   0.000414   0.000083   let col = s:Match(info.plnum, '\%(^\|[^.:@$]\)\<end\>\s*\%(#.*\)\=$')
    4              0.000006   if col > 0
                                call cursor(info.plnum, col)
                                if searchpair(s:end_start_regex, '', s:end_end_regex, 'bW', s:end_skip_expr) > 0
                                  let n = line('.')
                                  let ind = indent('.')
                                  let msl = s:GetMSL(n)
                                  if msl != n
                                    let ind = indent(msl)
                                  end
                                  return ind
                                endif
    4              0.000005   end
    4              0.000007   return -1

FUNCTION  <SNR>132_DisableOnLargeFile()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 413
Called 118 times
Total time:   0.001144
 Self time:   0.001144

count  total (s)   self (s)
  118              0.000683   if exists( 'b:ycm_largefile' )
  118              0.000301     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                exec s:python_command "vimsupport.PostVimMessage(" . "'YouCompleteMe is disabled in this buffer; " . "the file exceeded the max size (see YCM options).' )"
                              endif
                              return b:ycm_largefile

FUNCTION  <SNR>124_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 37
Called 1520 times
Total time:   0.054076
 Self time:   0.054076

count  total (s)   self (s)
 1520              0.005489   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
 1520              0.001232   endif
 1520              0.002305   let color = ''
 1520              0.007766   if hlexists(a:group)
 1480              0.011281     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1520              0.001224   endif
 1520              0.004124   if empty(color) || color == -1
                                " should always exists
   40              0.000274     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
   40              0.000088     if empty(color) || color == -1
                                  let color = 'NONE'
   40              0.000026     endif
 1520              0.000981   endif
 1520              0.002407   return color

FUNCTION  <SNR>132_OnTextChangedInsertMode()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 699
Called 40 times
Total time:   0.355823
 Self time:   0.018827

count  total (s)   self (s)
   40   0.005564   0.000990   if !s:AllowedToCompleteInCurrentBuffer()
                                return
   40              0.000024   endif
                            
   40              0.000066   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
   40              0.000027   endif
                            
   40   0.016791   0.001040   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
   40              0.000198   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
   40              0.000059   endif
                            
   40   0.078624   0.002378   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
   38   0.002606   0.000873     call s:Complete()
   38   0.239355   0.000663     call s:InvokeCompletion()
   40              0.000063   endif
                            
   40              0.011218   exec s:python_command "ycm_state.OnCursorMoved()"
                            
   40              0.000230   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
   40              0.000054   endif

FUNCTION  <SNR>136_get_separator_change()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim line 68
Called 12 times
Total time:   0.005179
 Self time:   0.000446

count  total (s)   self (s)
   12   0.005168   0.000435   return s:get_separator_change_with_end(a:new_group, a:old_group, a:end_group, a:end_group, a:sep_size, a:alt_sep_size)

FUNCTION  <SNR>146_IsInString()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 697
Called 3 times
Total time:   0.001672
 Self time:   0.000081

count  total (s)   self (s)
    3   0.001669   0.000078   return s:IsInRubyGroup(s:syng_string, a:lnum, a:col)

FUNCTION  <SNR>111_update_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 173
Called 94 times
Total time:   0.030524
 Self time:   0.016575

count  total (s)   self (s)
   94              0.002889   let file = expand("%:p")
   94              0.000703   if empty(file) || isdirectory(file)
                                return
   94              0.000081   endif
                            
   94              0.000209   let needs_update = 1
  282              0.000788   for vcs in keys(s:vcs_config)
  188              0.001377     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
  188              0.000162     endif
  188              0.000788     if has_key(s:vcs_config[vcs].untracked, file)
   86              0.000154       let needs_update = 0
   86   0.004730   0.003022       call airline#extensions#branch#update_untracked_config(file, vcs)
  188              0.000282     endif
  282              0.000282   endfor
                            
   94              0.000143   if !needs_update
   86              0.000134     return
    8              0.000007   endif
                            
   24              0.000175   for vcs in keys(s:vcs_config)
   16              0.000125     let config = s:vcs_config[vcs]
   16              0.000043     if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
   16   0.013852   0.001611       noa call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
                                  noa call airline#async#nvim_vcs_untracked(config, file, vcs)
   16              0.000025     endif
   24              0.000205   endfor

FUNCTION  <SNR>111_update_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 154
Called 94 times
Total time:   0.043908
 Self time:   0.009067

count  total (s)   self (s)
  282              0.000970   for vcs in keys(s:vcs_config)
  188   0.039382   0.004541     call {s:vcs_config[vcs].update_branch}()
  188              0.001051     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
  188              0.000177     endif
  282              0.000308   endfor

FUNCTION  gutentags#ctags#on_job_exit()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags/ctags.vim line 179
Called 4 times
Total time:   0.001098
 Self time:   0.000148

count  total (s)   self (s)
    4   0.001063   0.000113     call gutentags#remove_job_by_data('ctags', a:job)
                            
    4              0.000009     if a:exit_val != 0
                                    call gutentags#warning("gutentags: ctags job failed, returned: ".string(a:exit_val))
    4              0.000003     endif

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 199
Called 120 times
Total time:   0.246955
 Self time:   0.020560

count  total (s)   self (s)
  120              0.000730   if !has_key(s:contexts, a:winnr)
                                return ''
  120              0.000206   endif
  120              0.000595   let context = s:contexts[a:winnr]
                            
  120              0.000701   if get(w:, 'airline_active', 1)
   94              0.000423     let l:m = mode(1)
   94              0.000238     if l:m ==# "i"
   54              0.000199       let l:mode = ['insert']
   40              0.000144     elseif l:m[0] ==# "i"
   18              0.000058       let l:mode = ['insert']
   22              0.000040     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
   22              0.000828     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
   22              0.000362     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
   22              0.000035     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
   22              0.000057     elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
   22              0.000035     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
   22              0.000079     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
   22              0.000023     else
   22              0.000115       let l:mode = ['normal']
   94              0.000085     endif
   94              0.000677     if index(['Rv', 'no', 'ni', 'ix', 'ic'], l:m) == -1
   76              0.000245       let l:m = l:m[0]
   94              0.000084     endif
   94              0.000617     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   26              0.000028   else
   26              0.000072     let l:mode = ['inactive']
   26              0.000141     let w:airline_current_mode = get(g:airline_mode_map, '__')
  120              0.000109   endif
                            
  120              0.000592   if g:airline_detect_modified && &modified
   75              0.000381     call add(l:mode, 'modified')
  120              0.000106   endif
                            
  120              0.000299   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
  120              0.000088   endif
                            
  120              0.000704   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
  120              0.000077   endif
                            
  120              0.000358   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
  120              0.000085   endif
                            
  120              0.000254   if &readonly || ! &modifiable
   26              0.000132     call add(l:mode, 'readonly')
  120              0.000092   endif
                            
  120              0.000870   let mode_string = join(l:mode)
  120              0.000615   if get(w:, 'airline_lastmode', '') != mode_string
    7   0.005098   0.000279     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    7   0.220972   0.000326     call airline#highlighter#highlight(l:mode, context.bufnr)
    7   0.001280   0.000350     call airline#util#doautocmd('AirlineModeChanged')
    7              0.000024     let w:airline_lastmode = mode_string
  120              0.000085   endif
                            
  120              0.000204   return ''

FUNCTION  <SNR>146_AfterUnbalancedBracket()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 535
Called 4 times
Total time:   0.011295
 Self time:   0.000532

count  total (s)   self (s)
    4              0.000018   let info = a:pline_info
                            
                              " If the previous line contained unclosed opening brackets and we are still
                              " in them, find the rightmost one and add indent depending on the bracket
                              " type.
                              "
                              " If it contained hanging closing brackets, find the rightmost one, find its
                              " match and indent according to that.
    4              0.000077   if info.pline =~ '[[({]' || info.pline =~ '[])}]\s*\%(#.*\)\=$'
    4   0.010890   0.000127     let [opening, closing] = s:ExtraBrackets(info.plnum)
                            
    4              0.000010     if opening.pos != -1
                                  if opening.type == '(' && searchpair('(', '', ')', 'bW', s:skip_expr) > 0
                                    if col('.') + 1 == col('$')
                                      return indent(info.plnum) + info.sw
                                    else
                                      return virtcol('.')
                                    endif
                                  else
                                    let nonspace = matchend(info.pline, '\S', opening.pos + 1) - 1
                                    return nonspace > 0 ? nonspace : indent(info.plnum) + info.sw
                                  endif
    4              0.000007     elseif closing.pos != -1
                                  call cursor(info.plnum, closing.pos + 1)
                                  normal! %
                            
                                  if s:Match(line('.'), s:ruby_indent_keywords)
                                    return indent('.') + info.sw
                                  else
                                    return indent(s:GetMSL(line('.')))
                                  endif
    4              0.000019     else
    4              0.000029       call cursor(info.clnum, info.col)
    4              0.000004     end
    4              0.000004   endif
                            
    4              0.000007   return -1

FUNCTION  <SNR>113_new_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim line 35
Called 188 times
Total time:   0.001009
 Self time:   0.001009

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
  188              0.000379   if a:cnt == 0
  188              0.000207     return ''
                              endif
                              let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
                              let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
                              if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
                              if empty(l:result)
                                  return ''
                              endif
                            
                              let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 43
Called 658 times
Total time:   0.008614
 Self time:   0.008614

count  total (s)   self (s)
  658              0.002019   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  658              0.000488   endif
  658              0.002621   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  658              0.002219   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  gutentags#ctags#generate()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags/ctags.vim line 71
Called 4 times
Total time:   0.012026
 Self time:   0.003529

count  total (s)   self (s)
    4              0.000027     let l:write_mode = a:gen_opts['write_mode']
                            
    4              0.000108     let l:tags_file_exists = filereadable(a:tags_file)
    4              0.000073     let l:tags_file_relative = fnamemodify(a:tags_file, ':.')
    4              0.000035     let l:tags_file_is_local = len(l:tags_file_relative) < len(a:tags_file)
                            
    4              0.000016     if l:tags_file_exists && g:gutentags_ctags_check_tagfile
                                    let l:first_lines = readfile(a:tags_file, '', 1)
                                    if len(l:first_lines) == 0 || stridx(l:first_lines[0], '!_TAG_') != 0
                                        call gutentags#throw("File ".a:tags_file." doesn't appear to be "."a ctags file. Please delete it and run ".":GutentagsUpdate!.")
                                        return
                                    endif
    4              0.000009     endif
                            
    4              0.000018     if empty(g:gutentags_cache_dir) && l:tags_file_is_local
                                    " If we don't use the cache directory, we can pass relative paths
                                    " around.
                                    "
                                    " Note that if we don't do this and pass a full path for the project
                                    " root, some `ctags` implementations like Exhuberant Ctags can get
                                    " confused if the paths have spaces -- but not if you're *in* the root 
                                    " directory, for some reason... (which we are, our caller in
                                    " `autoload/gutentags.vim` changed it).
                                    let l:actual_proj_dir = '.'
                                    let l:actual_tags_file = l:tags_file_relative
    4              0.000006     else
                                    " else: the tags file goes in a cache directory, so we need to specify
                                    " all the paths absolutely for `ctags` to do its job correctly.
    4              0.000013         let l:actual_proj_dir = a:proj_dir
    4              0.000012         let l:actual_tags_file = a:tags_file
    4              0.000005     endif
                            
                                " Build the command line.
    4              0.000025     let l:cmd = [s:runner_exe]
    4   0.000558   0.000169     let l:cmd += ['-e', '"' . s:get_ctags_executable(a:proj_dir) . '"']
    4              0.000024     let l:cmd += ['-t', '"' . l:actual_tags_file . '"']
    4              0.000036     let l:cmd += ['-p', '"' . l:actual_proj_dir . '"']
    4              0.000016     if l:write_mode == 0 && l:tags_file_exists
    4              0.000105         let l:cur_file_path = expand('%:p')
    4              0.000018         if empty(g:gutentags_cache_dir) && l:tags_file_is_local
                                        let l:cur_file_path = fnamemodify(l:cur_file_path, ':.')
    4              0.000004         endif
    4              0.000020         let l:cmd += ['-s', '"' . l:cur_file_path . '"']
                                else
                                    let l:file_list_cmd = gutentags#get_project_file_list_cmd(l:actual_proj_dir)
                                    if !empty(l:file_list_cmd)
                                        if match(l:file_list_cmd, '///') > 0
                                            let l:suffopts = split(l:file_list_cmd, '///')
                                            let l:suffoptstr = l:suffopts[1]
                                            let l:file_list_cmd = l:suffopts[0]
                                            if l:suffoptstr == 'absolute'
                                                let l:cmd += ['-A']
                                            endif
                                        endif
                                        let l:cmd += ['-L', '"' . l:file_list_cmd. '"']
                                    endif
    4              0.000003     endif
    4              0.000019     if empty(get(l:, 'file_list_cmd', ''))
                                    " Pass the Gutentags recursive options file before the project
                                    " options file, so that users can override --recursive.
                                    " Omit --recursive if this project uses a file list command.
    4   0.000173   0.000146         let l:cmd += ['-o', '"' . gutentags#get_res_file('ctags_recursive.options') . '"']
    4              0.000004     endif
    4              0.000015     if !empty(g:gutentags_ctags_extra_args)
                                    let l:cmd += ['-O', shellescape(join(g:gutentags_ctags_extra_args))]
    4              0.000002     endif
    4              0.000012     if !empty(g:gutentags_ctags_post_process_cmd)
                                    let l:cmd += ['-P', shellescape(g:gutentags_ctags_post_process_cmd)]
    4              0.000003     endif
    4              0.000024     let l:proj_options_file = a:proj_dir . '/' .g:gutentags_ctags_options_file
    4              0.000042     if filereadable(l:proj_options_file)
                                    let l:proj_options_file = s:process_options_file(a:proj_dir, l:proj_options_file)
                                    let l:cmd += ['-o', '"' . l:proj_options_file . '"']
    4              0.000003     endif
    4              0.000011     if g:gutentags_ctags_exclude_wildignore
    4   0.000342   0.000162         call s:generate_wildignore_options()
    4              0.000014         if !empty(s:wildignores_options_path)
                                        let l:cmd += ['-x', shellescape('@'.s:wildignores_options_path, 1)]
    4              0.000004         endif
    4              0.000004     endif
    4              0.000016     for exc in g:gutentags_ctags_exclude
                                    let l:cmd += ['-x', '"' . exc . '"']
    4              0.000007     endfor
    4              0.000009     if g:gutentags_pause_after_update
                                    let l:cmd += ['-c']
    4              0.000002     endif
    4              0.000006     if g:gutentags_trace
                                    let l:cmd += ['-l', '"' . l:actual_tags_file . '.log"']
    4              0.000004     endif
    4   0.001367   0.000128     let l:cmd = gutentags#make_args(l:cmd)
                            
    4   0.000301   0.000256     call gutentags#trace("Running: " . string(l:cmd))
    4   0.000126   0.000096     call gutentags#trace("In:      " . getcwd())
    4              0.000008     if !g:gutentags_fake
    4   0.000181   0.000110         let l:job_opts = gutentags#build_default_job_options('ctags')
    4   0.006620   0.000274         let l:job = gutentags#start_job(l:cmd, l:job_opts)
    4   0.000731   0.000561         call gutentags#add_job('ctags', a:tags_file, l:job)
                                else
                                    call gutentags#trace("(fake... not actually running)")
    4              0.000022     endif

FUNCTION  AutoSave()
    Defined: ~/.vim/plugged/vim-auto-save/plugin/AutoSave.vim line 46
Called 7 times
Total time:   0.168528
 Self time:   0.077405

count  total (s)   self (s)
    7              0.000064   if g:auto_save >= 1
    7              0.000070     let was_modified = &modified
    7   0.167524   0.076401     silent! wa
    7              0.000042     if was_modified && !&modified
    4              0.000028       if exists("g:auto_save_postsave_hook")
                                    execute "" . g:auto_save_postsave_hook
    4              0.000004       endif
    4              0.000014       if g:auto_save_silent == 0
    4              0.000617         echo "(AutoSaved at " . strftime("%H:%M:%S") . ")"
    4              0.000018       endif
    7              0.000009     endif
    7              0.000009   endif

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 164
Called 94 times
Total time:   0.001949
 Self time:   0.001949

count  total (s)   self (s)
   94              0.000567   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
    4              0.000008     return
   90              0.000622   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
   90              0.000075   endif

FUNCTION  gutentags#find_job_index_by_tags_file()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 355
Called 98 times
Total time:   0.002006
 Self time:   0.002006

count  total (s)   self (s)
   98              0.000334     let l:idx = -1
   98              0.000537     for upd_info in s:update_in_progress[a:module]
    8              0.000028         let l:idx += 1
    8              0.000102         if upd_info[0] == a:tags_file
    8              0.000020             return l:idx
                                    endif
   90              0.000124     endfor
   90              0.000112     return -1

FUNCTION  <SNR>113_ale_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim line 125
Called 9 times
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
    9              0.000127   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
    9              0.000011   endif

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim line 31
Called 320 times
Total time:   0.063898
 Self time:   0.007673

count  total (s)   self (s)
  320   0.063755   0.007530   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 275
Called 7 times
Total time:   0.000307
 Self time:   0.000247

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    7              0.000112   let g:airline#visual_active = (mode() =~? '[vs]')
    7   0.000182   0.000122   call airline#update_tabline()

FUNCTION  <SNR>154_on_stdout()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim line 61
Called 7 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    7              0.000091     let self.buf .= a:msg

FUNCTION  <SNR>132_OnTextChangedNormalMode()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 690
Called 4 times
Total time:   0.010177
 Self time:   0.000235

count  total (s)   self (s)
    4   0.000602   0.000124   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    4              0.000004   endif
                            
    4   0.009556   0.000092   call s:OnFileReadyToParse()

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim line 18
Called 94 times
Total time:   0.005605
 Self time:   0.005605

count  total (s)   self (s)
   94              0.000465   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
                                endtry
   94              0.000077   endif
                            
   94              0.000252   if empty(b:fugitive_name)
   94              0.002398     return fnamemodify(bufname('%'), s:fmod)
                              else
                                return fnamemodify(b:fugitive_name, s:fmod). " [git]"
                              endif

FUNCTION  ale#statusline#Count()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim line 119
Called 188 times
Total time:   0.015407
 Self time:   0.004057

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
  188   0.015154   0.003804     return copy(s:GetCounts(a:buffer))

FUNCTION  sy#repo#get_diff_start()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 65
Called 4 times
Total time:   0.008043
 Self time:   0.007047

count  total (s)   self (s)
    4   0.000113   0.000055   call sy#verbose('get_diff_start()', a:vcs)
                            
    4              0.000019   let job_id = get(b:, 'sy_job_id_'.a:vcs)
                              " Neovim
    4              0.000015   if has('nvim')
                                if job_id
                                  silent! call jobstop(job_id)
                                endif
                            
                                let [cmd, options] = s:initialize_job(a:vcs)
                                let [cwd, chdir] = sy#util#chdir()
                            
                                call sy#verbose(['CMD: '. string(cmd), 'CMD DIR:  '. b:sy.info.dir, 'ORIG DIR: '. cwd], a:vcs)
                            
                                try
                                  execute chdir fnameescape(b:sy.info.dir)
                                catch
                                  echohl ErrorMsg
                                  echomsg 'signify: Changing directory failed: '. b:sy.info.dir
                                  echohl NONE
                                  return
                                endtry
                                let b:sy_job_id_{a:vcs} = jobstart(cmd, extend(options, { 'on_stdout': function('s:callback_nvim_stdout'), 'on_exit':   function('s:callback_nvim_exit'), }))
                                execute chdir fnameescape(cwd)
                            
                              " Newer Vim
    4              0.000016   elseif has('patch-7.4.1967')
    4              0.000012     if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
    4              0.000003     endif
                            
    4   0.000884   0.000082     let [cmd, options] = s:initialize_job(a:vcs)
    4   0.000134   0.000067     let [cwd, chdir] = sy#util#chdir()
                            
    4   0.000157   0.000088     call sy#verbose(['CMD: '. string(cmd), 'CMD DIR:  '. b:sy.info.dir, 'ORIG DIR: '. cwd], a:vcs)
                            
    4              0.000006     try
    4              0.000175       execute chdir fnameescape(b:sy.info.dir)
                                catch
                                  echohl ErrorMsg
                                  echomsg 'signify: Changing directory failed: '. b:sy.info.dir
                                  echohl NONE
                                  return
    4              0.000006     endtry
    4              0.000056     let opts = { 'in_io':    'null', 'out_cb':   function('s:callback_vim_stdout', options), 'close_cb': function('s:callback_vim_close', options), }
    4              0.005683     let b:sy_job_id_{a:vcs} = job_start(cmd, opts)
    4              0.000410     execute chdir fnameescape(cwd)
                            
                              " Older Vim
                              else
                                let diff = split(s:run(a:vcs), '\n')
                                call sy#repo#get_diff_{a:vcs}(b:sy, v:shell_error, diff)
    4              0.000004   endif

FUNCTION  <SNR>153_get_vcs_path()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 322
Called 4 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    4              0.000078   return (a:vcs =~# '\v(git|cvs|accurev|tfs)') ? b:sy.info.file : b:sy.info.path

FUNCTION  <SNR>156_DefRuby()
    Defined: ~/.vim/plugged/vim-ruby/autoload/rubycomplete.vim line 246
Called 1 time
Total time:   0.090109
 Self time:   0.090109

count  total (s)   self (s)
    1              0.000001 ruby << RUBYEOF
                            # {{{ ruby completion
                            
                            begin
                                require 'rubygems' # let's assume this is safe...?
                            rescue Exception
                                #ignore?
                            end
                            class VimRubyCompletion
                            # {{{ constants
                              @@debug = false
                              @@ReservedWords = [
                                    "BEGIN", "END",
                                    "alias", "and",
                                    "begin", "break",
                                    "case", "class",
                                    "def", "defined", "do",
                                    "else", "elsif", "end", "ensure",
                                    "false", "for",
                                    "if", "in",
                                    "module",
                                    "next", "nil", "not",
                                    "or",
                                    "redo", "rescue", "retry", "return",
                                    "self", "super",
                                    "then", "true",
                                    "undef", "unless", "until",
                                    "when", "while",
                                    "yield",
                                  ]
                            
                              @@Operators = [ "%", "&", "*", "**", "+",  "-",  "/",
                                    "<", "<<", "<=", "<=>", "==", "===", "=~", ">", ">=", ">>",
                                    "[]", "[]=", "^", ]
                            # }}} constants
                            
                            # {{{ buffer analysis magic
                              def load_requires
                            
                                custom_paths = VIM::evaluate("get(g:, 'rubycomplete_load_paths', [])")
                            
                                if !custom_paths.empty?
                                  $LOAD_PATH.concat(custom_paths).uniq!
                                end
                            
                                buf = VIM::Buffer.current
                                enum = buf.line_number
                                nums = Range.new( 1, enum )
                                nums.each do |x|
                            
                                  ln = buf[x]
                                  begin
                                    if /.*require_relative\s*(.*)$/.match( ln )
                                      eval( "require %s" % File.expand_path($1) )
                                    elsif /.*require\s*(["'].*?["'])/.match( ln )
                                      eval( "require %s" % $1 )
                                    end
                                  rescue Exception => e
                                    dprint e.inspect
                                  end
                                end
                              end
                            
                              def load_gems
                                fpath = VIM::evaluate("get(g:, 'rubycomplete_gemfile_path', 'Gemfile')")
                                return unless File.file?(fpath) && File.readable?(fpath)
                                want_bundler = VIM::evaluate("get(g:, 'rubycomplete_use_bundler')")
                                parse_file = !want_bundler
                                begin
                                  require 'bundler'
                                  Bundler.setup
                                  Bundler.require
                                rescue Exception
                                  parse_file = true
                                end
                                if parse_file
                                  File.new(fpath).each_line do |line|
                                    begin
                                      require $1 if /\s*gem\s*['"]([^'"]+)/.match(line)
                                    rescue Exception
                                    end
                                  end
                                end
                              end
                            
                              def load_buffer_class(name)
                                dprint "load_buffer_class(%s) START" % name
                                classdef = get_buffer_entity(name, 's:GetBufferRubyClass("%s")')
                                return if classdef == nil
                            
                                pare = /^\s*class\s*(.*)\s*<\s*(.*)\s*\n/.match( classdef )
                                load_buffer_class( $2 ) if pare != nil  && $2 != name # load parent class if needed
                            
                                mixre = /.*\n\s*(include|prepend)\s*(.*)\s*\n/.match( classdef )
                                load_buffer_module( $2 ) if mixre != nil && $2 != name # load mixins if needed
                            
                                begin
                                  eval classdef
                                rescue Exception
                                  VIM::evaluate( "s:ErrMsg( 'Problem loading class \"%s\", was it already completed?' )" % name )
                                end
                                dprint "load_buffer_class(%s) END" % name
                              end
                            
                              def load_buffer_module(name)
                                dprint "load_buffer_module(%s) START" % name
                                classdef = get_buffer_entity(name, 's:GetBufferRubyModule("%s")')
                                return if classdef == nil
                            
                                begin
                                  eval classdef
                                rescue Exception
                                  VIM::evaluate( "s:ErrMsg( 'Problem loading module \"%s\", was it already completed?' )" % name )
                                end
                                dprint "load_buffer_module(%s) END" % name
                              end
                            
                              def get_buffer_entity(name, vimfun)
                                loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
                                return nil if loading_allowed.to_i.zero?
                                return nil if /(\"|\')+/.match( name )
                                buf = VIM::Buffer.current
                                nums = eval( VIM::evaluate( vimfun % name ) )
                                return nil if nums == nil
                                return nil if nums.min == nums.max && nums.min == 0
                            
                                dprint "get_buffer_entity START"
                                visited = []
                                clscnt = 0
                                bufname = VIM::Buffer.current.name
                                classdef = ""
                                cur_line = VIM::Buffer.current.line_number
                                while (nums != nil && !(nums.min == 0 && nums.max == 0) )
                                  dprint "visited: %s" % visited.to_s
                                  break if visited.index( nums )
                                  visited << nums
                            
                                  nums.each do |x|
                                    if x != cur_line
                                      next if x == 0
                                      ln = buf[x]
                                      is_const = false
                                      if /^\s*(module|class|def|include)\s+/.match(ln) || is_const = /^\s*?[A-Z]([A-z]|[1-9])*\s*?[|]{0,2}=\s*?.+\s*?/.match(ln)
                                        clscnt += 1 if /class|module/.match($1)
                                        # We must make sure to load each constant only once to avoid errors
                                        if is_const
                                            ln.gsub!(/\s*?[|]{0,2}=\s*?/, '||=')
                                        end
                                        #dprint "\$1$1
                                        classdef += "%s\n" % ln
                                        classdef += "end\n" if /def\s+/.match(ln)
                                        dprint ln
                                      end
                                    end
                                  end
                            
                                  nm = "%s(::.*)*\", %s, \"" % [ name, nums.last ]
                                  nums = eval( VIM::evaluate( vimfun % nm ) )
                                  dprint "nm: \"%s\"" % nm
                                  dprint "vimfun: %s" % (vimfun % nm)
                                  dprint "got nums: %s" % nums.to_s
                                end
                                if classdef.length > 1
                                    classdef += "end\n"*clscnt
                                    # classdef = "class %s\n%s\nend\n" % [ bufname.gsub( /\/|\\/, "_" ), classdef ]
                                end
                            
                                dprint "get_buffer_entity END"
                                dprint "classdef====start"
                                lns = classdef.split( "\n" )
                                lns.each { |x| dprint x }
                                dprint "classdef====end"
                                return classdef
                              end
                            
                              def get_var_type( receiver )
                                if /(\"|\')+/.match( receiver )
                                  "String"
                                else
                                  VIM::evaluate("s:GetRubyVarType('%s')" % receiver)
                                end
                              end
                            
                              def dprint( txt )
                                print txt if @@debug
                              end
                            
                              def escape_vim_singlequote_string(str)
                                str.to_s.gsub(/'/,"\\'")
                              end
                            
                              def get_buffer_entity_list( type )
                                # this will be a little expensive.
                                loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
                                allow_aggressive_load = VIM::evaluate("exists('g:rubycomplete_classes_in_global') && g:rubycomplete_classes_in_global")
                                return [] if allow_aggressive_load.to_i.zero? || loading_allowed.to_i.zero?
                            
                                buf = VIM::Buffer.current
                                eob = buf.length
                                ret = []
                                rg = 1..eob
                                re = eval( "/^\s*%s\s*([A-Za-z0-9_:-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*/" % type )
                            
                                rg.each do |x|
                                  if re.match( buf[x] )
                                    next if type == "def" && eval( VIM::evaluate("s:IsPosInClassDef(%s)" % x) ) != nil
                                    ret.push $1
                                  end
                                end
                            
                                return ret
                              end
                            
                              def get_buffer_modules
                                return get_buffer_entity_list( "modules" )
                              end
                            
                              def get_buffer_methods
                                return get_buffer_entity_list( "def" )
                              end
                            
                              def get_buffer_classes
                                return get_buffer_entity_list( "class" )
                              end
                            
                              def load_rails
                                allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
                                return if allow_rails.to_i.zero?
                            
                                buf_path = VIM::evaluate('expand("%:p")')
                                file_name = VIM::evaluate('expand("%:t")')
                                vim_dir = VIM::evaluate('getcwd()')
                                file_dir = buf_path.gsub( file_name, '' )
                                file_dir.gsub!( /\\/, "/" )
                                vim_dir.gsub!( /\\/, "/" )
                                vim_dir << "/"
                                dirs = [ vim_dir, file_dir ]
                                sdirs = [ "", "./", "../", "../../", "../../../", "../../../../" ]
                                rails_base = nil
                            
                                dirs.each do |dir|
                                  sdirs.each do |sub|
                                    trail = "%s%s" % [ dir, sub ]
                                    tcfg = "%sconfig" % trail
                            
                                    if File.exists?( tcfg )
                                      rails_base = trail
                                      break
                                    end
                                  end
                                  break if rails_base
                                end
                            
                                return if rails_base == nil
                                $:.push rails_base unless $:.index( rails_base )
                            
                                rails_config = rails_base + "config/"
                                rails_lib = rails_base + "lib/"
                                $:.push rails_config unless $:.index( rails_config )
                                $:.push rails_lib unless $:.index( rails_lib )
                            
                                bootfile = rails_config + "boot.rb"
                                envfile = rails_config + "environment.rb"
                                if File.exists?( bootfile ) && File.exists?( envfile )
                                  begin
                                    require bootfile
                                    require envfile
                                    begin
                                      require 'console_app'
                                      require 'console_with_helpers'
                                    rescue Exception
                                      dprint "Rails 1.1+ Error %s" % $!
                                      # assume 1.0
                                    end
                                    #eval( "Rails::Initializer.run" ) #not necessary?
                                    VIM::command('let s:rubycomplete_rails_loaded = 1')
                                    dprint "rails loaded"
                                  rescue Exception
                                    dprint "Rails Error %s" % $!
                                    VIM::evaluate( "s:ErrMsg('Error loading rails environment')" )
                                  end
                                end
                              end
                            
                              def get_rails_helpers
                                allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
                                rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
                                return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?
                            
                                buf_path = VIM::evaluate('expand("%:p")')
                                buf_path.gsub!( /\\/, "/" )
                                path_elm = buf_path.split( "/" )
                                dprint "buf_path: %s" % buf_path
                                types = [ "app", "db", "lib", "test", "components", "script" ]
                            
                                i = nil
                                ret = []
                                type = nil
                                types.each do |t|
                                  i = path_elm.index( t )
                                  break if i
                                end
                                type = path_elm[i]
                                type.downcase!
                            
                                dprint "type: %s" % type
                                case type
                                  when "app"
                                    i += 1
                                    subtype = path_elm[i]
                                    subtype.downcase!
                            
                                    dprint "subtype: %s" % subtype
                                    case subtype
                                      when "views"
                                        ret += ActionView::Base.instance_methods
                                        ret += ActionView::Base.methods
                                      when "controllers"
                                        ret += ActionController::Base.instance_methods
                                        ret += ActionController::Base.methods
                                      when "models"
                                        ret += ActiveRecord::Base.instance_methods
                                        ret += ActiveRecord::Base.methods
                                    end
                            
                                  when "db"
                                    ret += ActiveRecord::ConnectionAdapters::SchemaStatements.instance_methods
                                    ret += ActiveRecord::ConnectionAdapters::SchemaStatements.methods
                                end
                            
                                return ret
                              end
                            
                              def add_rails_columns( cls )
                                allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
                                rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
                                return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?
                            
                                begin
                                    eval( "#{cls}.establish_connection" )
                                    return [] unless eval( "#{cls}.ancestors.include?(ActiveRecord::Base).to_s" )
                                    col = eval( "#{cls}.column_names" )
                                    return col if col
                                rescue
                                    dprint "add_rails_columns err: (cls: %s) %s" % [ cls, $! ]
                                    return []
                                end
                                return []
                              end
                            
                              def clean_sel(sel, msg)
                                ret = sel.reject{|x|x.nil?}.uniq
                                ret = ret.grep(/^#{Regexp.quote(msg)}/) if msg != nil
                                ret
                              end
                            
                              def get_rails_view_methods
                                allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
                                rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
                                return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?
                            
                                buf_path = VIM::evaluate('expand("%:p")')
                                buf_path.gsub!( /\\/, "/" )
                                pelm = buf_path.split( "/" )
                                idx = pelm.index( "views" )
                            
                                return [] unless idx
                                idx += 1
                            
                                clspl = pelm[idx].camelize.pluralize
                                cls = clspl.singularize
                            
                                ret = []
                                begin
                                  ret += eval( "#{cls}.instance_methods" )
                                  ret += eval( "#{clspl}Helper.instance_methods" )
                                rescue Exception
                                  dprint "Error: Unable to load rails view helpers for %s: %s" % [ cls, $! ]
                                end
                            
                                return ret
                              end
                            # }}} buffer analysis magic
                            
                            # {{{ main completion code
                              def self.preload_rails
                                a = VimRubyCompletion.new
                                if VIM::evaluate("has('nvim')") == 0
                                  require 'thread'
                                  Thread.new(a) do |b|
                                    begin
                                    b.load_rails
                                    rescue
                                    end
                                  end
                                end
                                a.load_rails
                              rescue
                              end
                            
                              def self.get_completions(base)
                                b = VimRubyCompletion.new
                                b.get_completions base
                              end
                            
                              def get_completions(base)
                                loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
                                if loading_allowed.to_i == 1
                                  load_requires
                                  load_rails
                                end
                            
                                want_gems = VIM::evaluate("get(g:, 'rubycomplete_load_gemfile')")
                                load_gems unless want_gems.to_i.zero?
                            
                                input = VIM::Buffer.current.line
                                cpos = VIM::Window.current.cursor[1] - 1
                                input = input[0..cpos]
                                input += base
                                input.sub!(/.*[ \t\n\"\\'`><=;|&{(]/, '') # Readline.basic_word_break_characters
                                input.sub!(/self\./, '')
                                input.sub!(/.*((\.\.[\[(]?)|([\[(]))/, '')
                            
                                dprint 'input %s' % input
                                message = nil
                                receiver = nil
                                methods = []
                                variables = []
                                classes = []
                                constants = []
                            
                                case input
                                  when /^(\/[^\/]*\/)\.([^.]*)$/ # Regexp
                                    receiver = $1
                                    message = Regexp.quote($2)
                                    methods = Regexp.instance_methods(true)
                            
                                  when /^([^\]]*\])\.([^.]*)$/ # Array
                                    receiver = $1
                                    message = Regexp.quote($2)
                                    methods = Array.instance_methods(true)
                            
                                  when /^([^\}]*\})\.([^.]*)$/ # Proc or Hash
                                    receiver = $1
                                    message = Regexp.quote($2)
                                    methods = Proc.instance_methods(true) | Hash.instance_methods(true)
                            
                                  when /^(:[^:.]*)$/ # Symbol
                                    dprint "symbol"
                                    if Symbol.respond_to?(:all_symbols)
                                      receiver = $1
                                      message = $1.sub( /:/, '' )
                                      methods = Symbol.all_symbols.collect{|s| s.id2name}
                                      methods.delete_if { |c| c.match( /'/ ) }
                                    end
                            
                                  when /^::([A-Z][^:\.\(]*)?$/ # Absolute Constant or class methods
                                    dprint "const or cls"
                                    receiver = $1
                                    methods = Object.constants.collect{ |c| c.to_s }.grep(/^#{receiver}/)
                            
                                  when /^(((::)?[A-Z][^:.\(]*)+?)::?([^:.]*)$/ # Constant or class methods
                                    receiver = $1
                                    message = Regexp.quote($4)
                                    dprint "const or cls 2 [recv: \'%s\', msg: \'%s\']" % [ receiver, message ]
                                    load_buffer_class( receiver )
                                    load_buffer_module( receiver )
                                    begin
                                      constants = eval("#{receiver}.constants").collect{ |c| c.to_s }.grep(/^#{message}/)
                                      methods = eval("#{receiver}.methods").collect{ |m| m.to_s }.grep(/^#{message}/)
                                    rescue Exception
                                      dprint "exception: %s" % $!
                                      constants = []
                                      methods = []
                                    end
                            
                                  when /^(:[^:.]+)\.([^.]*)$/ # Symbol
                                    dprint "symbol"
                                    receiver = $1
                                    message = Regexp.quote($2)
                                    methods = Symbol.instance_methods(true)
                            
                                  when /^([0-9_]+(\.[0-9_]+)?(e[0-9]+)?)\.([^.]*)$/ # Numeric
                                    dprint "numeric"
                                    receiver = $1
                                    message = Regexp.quote($4)
                                    begin
                                      methods = eval(receiver).methods
                                    rescue Exception
                                      methods = []
                                    end
                            
                                  when /^(\$[^.]*)$/ #global
                                    dprint "global"
                                    methods = global_variables.grep(Regexp.new(Regexp.quote($1)))
                            
                                  when /^((\.?[^.]+)+?)\.([^.]*)$/ # variable
                                    dprint "variable"
                                    receiver = $1
                                    message = Regexp.quote($3)
                                    load_buffer_class( receiver )
                            
                                    cv = eval("self.class.constants")
                                    vartype = get_var_type( receiver )
                                    dprint "vartype: %s" % vartype
                            
                                    invalid_vartype = ['', "gets"]
                                    if !invalid_vartype.include?(vartype)
                                      load_buffer_class( vartype )
                            
                                      begin
                                        methods = eval("#{vartype}.instance_methods")
                                        variables = eval("#{vartype}.instance_variables")
                                      rescue Exception
                                        dprint "load_buffer_class err: %s" % $!
                                      end
                                    elsif (cv).include?(receiver)
                                      # foo.func and foo is local var.
                                      methods = eval("#{receiver}.methods")
                                      vartype = receiver
                                    elsif /^[A-Z]/ =~ receiver and /\./ !~ receiver
                                      vartype = receiver
                                      # Foo::Bar.func
                                      begin
                                        methods = eval("#{receiver}.methods")
                                      rescue Exception
                                      end
                                    else
                                      # func1.func2
                                      ObjectSpace.each_object(Module){|m|
                                        next if m.name != "IRB::Context" and
                                          /^(IRB|SLex|RubyLex|RubyToken)/ =~ m.name
                                        methods.concat m.instance_methods(false)
                                      }
                                    end
                                    variables += add_rails_columns( "#{vartype}" ) if vartype && !invalid_vartype.include?(vartype)
                            
                                  when /^\(?\s*[A-Za-z0-9:^@.%\/+*\(\)]+\.\.\.?[A-Za-z0-9:^@.%\/+*\(\)]+\s*\)?\.([^.]*)/
                                    message = $1
                                    methods = Range.instance_methods(true)
                            
                                  when /^\.([^.]*)$/ # unknown(maybe String)
                                    message = Regexp.quote($1)
                                    methods = String.instance_methods(true)
                            
                                else
                                  dprint "default/other"
                                  inclass = eval( VIM::evaluate("s:IsInClassDef()") )
                            
                                  if inclass != nil
                                    dprint "inclass"
                                    classdef = "%s\n" % VIM::Buffer.current[ inclass.min ]
                                    found = /^\s*class\s*([A-Za-z0-9_-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*\n$/.match( classdef )
                            
                                    if found != nil
                                      receiver = $1
                                      message = input
                                      load_buffer_class( receiver )
                                      begin
                                        methods = eval( "#{receiver}.instance_methods" )
                                        variables += add_rails_columns( "#{receiver}" )
                                      rescue Exception
                                        found = nil
                                      end
                                    end
                                  end
                            
                                  if inclass == nil || found == nil
                                    dprint "inclass == nil"
                                    methods = get_buffer_methods
                                    methods += get_rails_view_methods
                            
                                    cls_const = Class.constants
                                    constants = cls_const.select { |c| /^[A-Z_-]+$/.match( c ) }
                                    classes = eval("self.class.constants") - constants
                                    classes += get_buffer_classes
                                    classes += get_buffer_modules
                            
                                    include_objectspace = VIM::evaluate("exists('g:rubycomplete_include_objectspace') && g:rubycomplete_include_objectspace")
                                    ObjectSpace.each_object(Class) { |cls| classes << cls.to_s } if include_objectspace == "1"
                                    message = receiver = input
                                  end
                            
                                  methods += get_rails_helpers
                                  methods += Kernel.public_methods
                                end
                            
                                include_object = VIM::evaluate("exists('g:rubycomplete_include_object') && g:rubycomplete_include_object")
                                methods = clean_sel( methods, message )
                                methods = (methods-Object.instance_methods) if include_object == "0"
                                rbcmeth = (VimRubyCompletion.instance_methods-Object.instance_methods) # lets remove those rubycomplete methods
                                methods = (methods-rbcmeth)
                            
                                variables = clean_sel( variables, message )
                                classes = clean_sel( classes, message ) - ["VimRubyCompletion"]
                                constants = clean_sel( constants, message )
                            
                                valid = []
                                valid += methods.collect { |m| { :name => m.to_s, :type => 'm' } }
                                valid += variables.collect { |v| { :name => v.to_s, :type => 'v' } }
                                valid += classes.collect { |c| { :name => c.to_s, :type => 't' } }
                                valid += constants.collect { |d| { :name => d.to_s, :type => 'd' } }
                                valid.sort! { |x,y| x[:name] <=> y[:name] }
                            
                                outp = ""
                            
                                rg = 0..valid.length
                                rg.step(150) do |x|
                                  stpos = 0+x
                                  enpos = 150+x
                                  valid[stpos..enpos].each { |c| outp += "{'word':'%s','item':'%s','kind':'%s'}," % [ c[:name], c[:name], c[:type] ].map{|x|escape_vim_singlequote_string(x)} }
                                  outp.sub!(/,$/, '')
                            
                                  VIM::command("call extend(g:rubycomplete_completions, [%s])" % outp)
                                  outp = ""
                                end
                              end
                            # }}} main completion code
                            
                            end # VimRubyCompletion
                            # }}} ruby completion
                            RUBYEOF

FUNCTION  airline#extensions#tabline#buffers#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buffers.vim line 51
Called 29 times
Total time:   0.105798
 Self time:   0.003744

count  total (s)   self (s)
   29              0.000086   try
   29   0.016974   0.000597     call <sid>map_keys()
                              catch
                                " no-op
   29              0.000047   endtry
   29              0.000171   let cur = bufnr('%')
   29              0.000173   if cur == s:current_bufnr && &columns == s:column_width
   29              0.000251     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
   23              0.000075       return s:current_tabline
    6              0.000006     endif
    6              0.000006   endif
                            
    6   0.001416   0.000280   let b = airline#extensions#tabline#new_builder()
    6              0.000034   let tab_bufs = tabpagebuflist(tabpagenr())
    6              0.000014   let show_buf_label_first = 0
                            
    6              0.000029   if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
    6              0.000005   endif
    6              0.000009   if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers')
    6              0.000003   endif
                            
    6              0.000035   let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
    6              0.000015   let b.overflow_group = 'airline_tabhid'
    6   0.000297   0.000222   let b.buffers = airline#extensions#tabline#buflist#list()
    6              0.000023   if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
    6              0.000005   endif
                            
    6              0.000023   function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
    6              0.000061   if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
    6              0.000005   endif
                            
    6              0.000011   function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
    6              0.000060   let current_buffer = max([index(b.buffers, cur), 0])
    6              0.000038   let last_buffer = len(b.buffers) - 1
    6   0.000296   0.000084   call b.insert_titles(current_buffer, 0, last_buffer)
                            
    6   0.000137   0.000081   call b.add_section('airline_tabfill', '')
    6   0.000089   0.000041   call b.split()
    6   0.000115   0.000059   call b.add_section('airline_tabfill', '')
    6              0.000014   if !show_buf_label_first
    6   0.000569   0.000181     call airline#extensions#tabline#add_label(b, 'buffers')
    6              0.000006   endif
                            
    6              0.000024   if tabpagenr('$') > 1
                                call b.add_section_spaced('airline_tabmod', printf('%s %d/%d', "tab", tabpagenr(), tabpagenr('$')))
    6              0.000007   endif
                            
    6              0.000025   let s:current_bufnr = cur
    6              0.000026   let s:column_width = &columns
    6   0.083797   0.000091   let s:current_tabline = b.build()
    6              0.000046   let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
    6              0.000013   return s:current_tabline

FUNCTION  <SNR>49_MRU_Refresh_Menu()
    Defined: ~/.vim/plugged/mru/plugin/mru.vim line 751
Called 8 times
Total time:   0.024023
 Self time:   0.002868

count  total (s)   self (s)
    8              0.000108     if !has('menu') || !g:MRU_Add_Menu
                                    " No support for menus
                                    return
    8              0.000013     endif
                            
                                " Setup the cpoptions properly for the maps to work
    8              0.000058     let old_cpoptions = &cpoptions
    8              0.000102     set cpoptions&vim
                            
                                " Remove the MRU menu
                                " To retain the teared-off MRU menu, we need to add a dummy entry
    8              0.000142     silent! unmenu &File.&Recent\ Files
                                " The menu priority of the File menu is 10. If the MRU plugin runs
                                " first before menu.vim, the File menu order may not be correct.
                                " So specify the priority of the File menu here.
    8              0.000094     10noremenu &File.&Recent\ Files.Dummy <Nop>
    8              0.000468     silent! unmenu! &File.&Recent\ Files
                            
    8              0.000158     anoremenu <silent> &File.&Recent\ Files.Refresh\ list :call <SID>MRU_LoadList()<CR>
    8   0.000661   0.000459     exe 'tmenu File.&Recent\ Files.Refresh\ list Reload the MRU file list from ' . s:MRU_escape_filename(g:MRU_File)
    8              0.000067     anoremenu File.&Recent\ Files.-SEP1-           :
                            
                                " Add the filenames in the MRU list to the menu
    8              0.000054     let entry_cnt = len(s:MRU_files)
    8              0.000036     if entry_cnt > g:MRU_Max_Menu_Entries
                                    " Show only MRU_Max_Menu_Entries file names in the menu
    8              0.000176         let mru_list = s:MRU_files[0 : g:MRU_Max_Menu_Entries - 1]
    8              0.000028         let entry_cnt = g:MRU_Max_Menu_Entries
                                else
                                    let mru_list = s:MRU_files
    8              0.000011     endif
    8              0.000024     if entry_cnt > g:MRU_Max_Submenu_Entries
                            	" Split the MRU menu into sub-menus
                                    for start_idx in range(0, entry_cnt, g:MRU_Max_Submenu_Entries)
                                        let last_idx = start_idx + g:MRU_Max_Submenu_Entries - 1
                                        if last_idx >= entry_cnt
                                            let last_idx = entry_cnt - 1
                                        endif
                                        let prefix = 'Files\ (' . (start_idx + 1) . '\.\.\.' . (last_idx + 1) . ').'
                                        call s:MRU_add_files_to_menu(prefix, mru_list[start_idx : last_idx])
                                    endfor
    8              0.000009     else
    8   0.021293   0.000340         call s:MRU_add_files_to_menu('', mru_list)
    8              0.000009     endif
                            
                                " Remove the dummy menu entry
    8              0.000032     unmenu &File.&Recent\ Files.Dummy
                            
                                " Restore the previous cpoptions settings
    8              0.000070     let &cpoptions = old_cpoptions

FUNCTION  gutentags#find_job_index_by_data()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 366
Called 4 times
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    4              0.000036     let l:idx = -1
    4              0.000024     for upd_info in s:update_in_progress[a:module]
    4              0.000012         let l:idx += 1
    4              0.000034         if upd_info[1] == a:data
    4              0.000012             return l:idx
                                    endif
                                endfor
                                return -1

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 243
Called 7 times
Total time:   0.220646
 Self time:   0.035627

count  total (s)   self (s)
    7              0.000043   let bufnr = a:0 ? a:1 : ''
    7              0.000042   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    7              0.000115   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    7              0.000027   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    7              0.000018   let airline_grouplist = []
    7              0.000065   let buffers_in_tabpage = sort(tabpagebuflist())
    7              0.000034   if exists("*uniq")
    7              0.000036     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    7              0.000009   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   17              0.000067   for mode in reverse(mapped)
   10              0.000088     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   10              0.000042       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  189              0.000576       for kvp in items(dict)
  179              0.000534         let mode_colors = kvp[1]
  179              0.000389         let name = kvp[0]
  179              0.000571         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
  179              0.000134         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  179              0.002415         if name =~# 'airline_c\d\+'
   16              0.000252           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   16              0.000074           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
   16              0.000012           endif
  163              0.001072         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   88              0.000118           continue
   91              0.000074         endif
   91   0.003380   0.002184         if s:group_not_done(airline_grouplist, name.suffix)
   75   0.029390   0.001541           call airline#highlighter#exec(name.suffix, mode_colors)
   91              0.000081         endif
                            
  273              0.000717         for accent in keys(s:accents)
  182              0.000608           if !has_key(p.accents, accent)
                                        continue
  182              0.000136           endif
  182              0.000744           let colors = copy(mode_colors)
  182              0.000691           if p.accents[accent][0] != ''
   91              0.000342             let colors[0] = p.accents[accent][0]
  182              0.000126           endif
  182              0.000417           if p.accents[accent][2] != ''
   91              0.000263             let colors[2] = p.accents[accent][2]
  182              0.000114           endif
  182              0.000417           if len(colors) >= 5
  182              0.000770             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
  182              0.000128           endif
  182   0.006058   0.003990           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  150   0.058396   0.003066             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  182              0.000161           endif
  273              0.000335         endfor
  101              0.000090       endfor
                            
   10              0.000028       if empty(s:separators)
                                    " nothing to be done
                                    continue
   10              0.000004       endif
                                  " TODO: optimize this
  140              0.000403       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  130   0.101916   0.003340         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  140              0.000218       endfor
   10              0.000007     endif
   17              0.000053   endfor

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 117
Called 94 times
Total time:   0.000763
 Self time:   0.000763

count  total (s)   self (s)
   94              0.000567   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  <SNR>113_airline_ale_get_line_number()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim line 63
Called 188 times
Total time:   0.006910
 Self time:   0.005901

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
  188              0.000912   if exists("*ale#statusline#FirstProblem")
  188   0.005739   0.004730     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  <SNR>134_illuminate()
    Defined: ~/.vim/plugged/vim-illuminate/autoload/illuminate.vim line 76
Called 5 times
Total time:   0.001649
 Self time:   0.000618

count  total (s)   self (s)
    5              0.000034   if !s:enabled
                                return
    5              0.000007   endif
                            
    5   0.000550   0.000127   call s:remove_illumination()
                            
    5              0.000034   if exists('g:Illuminate_ftHighlightGroups') && has_key(g:Illuminate_ftHighlightGroups, &filetype)
                                if index(g:Illuminate_ftHighlightGroups[&filetype], synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')) >= 0
                                  call s:match_word(s:get_cur_word())
                                endif
    5              0.000006   else
    5   0.000606   0.000193     call s:match_word(s:get_cur_word())
    5              0.000003   endif
    5   0.000293   0.000098   let s:previous_match = s:get_cur_word()

FUNCTION  <SNR>124_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 25
Called 273 times
Total time:   0.003264
 Self time:   0.003264

count  total (s)   self (s)
  273              0.001292   if index(a:list, a:name) == -1
  225              0.000823     call add(a:list, a:name)
  225              0.000298     return 1
   48              0.000035   else
   48              0.000187     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
   48              0.000042     endif
   48              0.000053     return 0
                              endif

FUNCTION  <SNR>146_BlockComment()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 337
Called 8 times
Total time:   0.000233
 Self time:   0.000233

count  total (s)   self (s)
                              " If we have a =begin or =end set indent to first column.
    8              0.000182   if match(a:cline_info.cline, '^\s*\%(=begin\|=end\)$') != -1
                                return 0
    8              0.000007   endif
    8              0.000013   return -1

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 102
Called 94 times
Total time:   0.003247
 Self time:   0.001982

count  total (s)   self (s)
   94   0.003154   0.001889   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '' : '>') : &filetype

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 82
Called 94 times
Total time:   0.000796
 Self time:   0.000796

count  total (s)   self (s)
   94              0.000340   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
   94              0.000069   endif
   94              0.000116   return ''

FUNCTION  <SNR>146_AfterAccessModifier()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 442
Called 7 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
    7              0.000029   let info = a:pline_info
                            
    7              0.000026   if g:ruby_indent_access_modifier_style == 'indent'
                                " If the previous line was a private/protected keyword, add a
                                " level of indent.
                                if s:Match(info.plnum, s:indent_access_modifier_regex)
                                  return indent(info.plnum) + info.sw
                                endif
    7              0.000021   elseif g:ruby_indent_access_modifier_style == 'outdent'
                                " If the previous line was a private/protected/public keyword, add
                                " a level of indent, since the keyword has been out-dented.
                                if s:Match(info.plnum, s:access_modifier_regex)
                                  return indent(info.plnum) + info.sw
                                endif
    7              0.000006   endif
    7              0.000012   return -1

FUNCTION  <SNR>153_initialize_job()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 296
Called 4 times
Total time:   0.000802
 Self time:   0.000267

count  total (s)   self (s)
    4   0.000613   0.000078   let vcs_cmd = s:expand_cmd(a:vcs, g:signify_vcs_cmds)
    4              0.000020   if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ 'cmd' ? vcs_cmd : ['sh', '-c', vcs_cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = vcs_cmd
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, vcs_cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, vcs_cmd, &shellxquote])
                                  endif
                                endif
    4              0.000004   else
    4              0.000012     let cmd = ['sh', '-c', vcs_cmd]
    4              0.000004   endif
    4              0.000034   let options = { 'stdoutbuf':   [], 'vcs':         a:vcs, 'bufnr':       bufnr('%'), }
    4              0.000010   return [cmd, options]

FUNCTION  sy#verbose()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy.vim line 160
Called 32 times
Total time:   0.000556
 Self time:   0.000556

count  total (s)   self (s)
   32              0.000066   if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
   32              0.000023   endif

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 108
Called 94 times
Total time:   0.004856
 Self time:   0.004856

count  total (s)   self (s)
   94              0.000508   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
   94              0.000269   let bomb     = &l:bomb ? '[BOM]' : ''
   94              0.001895   let ff       = strlen(&ff) ? '['.&ff.']' : ''
   94              0.000894   if expected is# &fenc.bomb.ff
                                return ''
   94              0.000080   else
   94              0.000856     return &fenc.bomb.ff
                              endif

FUNCTION  <SNR>111_update_hg_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 119
Called 94 times
Total time:   0.011844
 Self time:   0.011333

count  total (s)   self (s)
   94   0.002210   0.001699   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
   94              0.000088   else
   94              0.000396     let s:vcs_config['mercurial'].branch = ''
   94              0.000089   endif

FUNCTION  <SNR>114_check_mixed_indent_file()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 32
Called 4 times
Total time:   0.000563
 Self time:   0.000563

count  total (s)   self (s)
    4              0.000059   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    4              0.000071   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
    4              0.000007   else
    4              0.000010     let head_spc = '\v(^ +)'
    4              0.000005   endif
    4              0.000236   let indent_tabs = search('\v(^\t+)', 'nw')
    4              0.000090   let indent_spc  = search(head_spc, 'nw')
    4              0.000015   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    4              0.000004   else
    4              0.000007     return ''
                              endif

FUNCTION  illuminate#on_insert_entered()
    Defined: ~/.vim/plugged/vim-illuminate/autoload/illuminate.vim line 47
Called 2 times
Total time:   0.000437
 Self time:   0.000195

count  total (s)   self (s)
    2   0.000141   0.000075   if s:should_illuminate_file()
    2   0.000285   0.000109     call s:remove_illumination()
    2              0.000003   endif

FUNCTION  airline#extensions#tabline#buflist#list()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/buflist.vim line 35
Called 41 times
Total time:   0.000388
 Self time:   0.000388

count  total (s)   self (s)
   41              0.000236   if exists('s:current_buffer_list')
   41              0.000102     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  gutentags#default_io_cb()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 570
Called 36 times
Total time:   0.001187
 Self time:   0.000842

count  total (s)   self (s)
   36   0.001166   0.000821     call gutentags#trace('[job output]: '.string(a:msg))

FUNCTION  <SNR>153_replace()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 352
Called 12 times
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
   12              0.000093   let parts = split(a:cmd, a:pat, 1)
   12              0.000052   return join(parts, a:sub)

FUNCTION  <SNR>132_OnDeleteChar()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 658
Called 2 times
Total time:   0.000536
 Self time:   0.000137

count  total (s)   self (s)
    2   0.000498   0.000099   if !s:AllowedToCompleteInCurrentBuffer()
                                return a:key
    2              0.000002   endif
                            
    2              0.000013   call timer_stop( s:pollers.completion.id )
    2              0.000006   if pumvisible()
                                return "\<C-y>" . a:key
    2              0.000002   endif
    2              0.000003   return a:key

FUNCTION  airline#extensions#ale#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim line 111
Called 94 times
Total time:   0.027434
 Self time:   0.001892

count  total (s)   self (s)
   94   0.027375   0.001833   return airline#extensions#ale#get('error')

FUNCTION  <SNR>113_airline_ale_count()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim line 6
Called 188 times
Total time:   0.000717
 Self time:   0.000717

count  total (s)   self (s)
  188              0.000594   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  ale#Var()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim line 165
Called 8 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    8              0.000042     let l:full_name = 'ale_' . a:variable_name
    8              0.000090     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
    8              0.000049     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>146_EmptyInsideString()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 418
Called 7 times
Total time:   0.007785
 Self time:   0.000429

count  total (s)   self (s)
                              " If the line is empty and inside a string (the previous line is a string,
                              " too), use the previous line's indent
    7              0.000020   let info = a:pline_info
                            
    7              0.000042   let plnum = prevnonblank(info.clnum - 1)
    7              0.000023   let pline = getline(plnum)
                            
    7   0.007598   0.000242   if info.cline =~ '^\s*$' && s:IsInStringOrComment(plnum, 1) && s:IsInStringOrComment(plnum, strlen(pline))
                                return indent(plnum)
    7              0.000012   endif
    7              0.000015   return -1

FUNCTION  gutentags#remove_job()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 385
Called 4 times
Total time:   0.000618
 Self time:   0.000470

count  total (s)   self (s)
    4              0.000032     let l:tags_file = s:update_in_progress[a:module][a:job_idx][0]
    4              0.000029     call remove(s:update_in_progress[a:module], a:job_idx)
                            
                                " Run the user callback for finished jobs.
    4   0.000226   0.000114     silent doautocmd User GutentagsUpdated
                            
                                " See if we had any more updates queued up for this.
    4              0.000013     let l:qu_idx = -1
    4              0.000023     for qu_info in s:update_queue[a:module]
                                    let l:qu_idx += 1
                                    if qu_info[0] == l:tags_file
                                        break
                                    endif
    4              0.000005     endfor
    4              0.000008     if l:qu_idx >= 0
                                    let l:qu_info = s:update_queue[a:module][l:qu_idx]
                                    call remove(s:update_queue[a:module], l:qu_idx)
                            
                                    if bufexists(l:qu_info[1])
                                        call gutentags#trace("Finished ".a:module." job, "."running queued update for '".l:tags_file."'.")
                                        call s:update_tags(l:qu_info[1], a:module, l:qu_info[2], 2)
                                    else
                                        call gutentags#trace("Finished ".a:module." job, "."but skipping queued update for '".l:tags_file."' "."because originating buffer doesn't exist anymore.")
                                    endif
    4              0.000004     else
    4   0.000125   0.000089         call gutentags#trace("Finished ".a:module." job.")
    4              0.000003     endif

FUNCTION  <SNR>132_InsideCommentOrString()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 781
Called 40 times
Total time:   0.069473
 Self time:   0.069473

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
   40              0.068559   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
   40              0.000324   if stridx(syntax_group, 'Comment') > -1
                                return 1
   40              0.000049   endif
                            
   40              0.000110   if stridx(syntax_group, 'String') > -1
                                return 2
   40              0.000024   endif
                            
   40              0.000062   return 0

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 13
Called 1065 times
Total time:   0.013424
 Self time:   0.013424

count  total (s)   self (s)
 1065              0.004200   let nr = get(a:000, 0, 0)
 1065              0.003148   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
 1065              0.000894   else
 1065              0.002642     return winwidth(nr)
                              endif

FUNCTION  <SNR>124_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 132
Called 392 times
Total time:   0.010743
 Self time:   0.010743

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  392              0.001758   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  392              0.000319   endif
  392              0.001452   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
  392              0.000276   endif
                            
  392              0.001176   for val in a:colors
  392              0.001160     if !empty(val) && val !=# 'NONE'
  392              0.000634       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 133
Called 7 times
Total time:   0.000930
 Self time:   0.000173

count  total (s)   self (s)
    7   0.000923   0.000166   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  illuminate#on_cursor_moved()
    Defined: ~/.vim/plugged/vim-illuminate/autoload/illuminate.vim line 17
Called 10 times
Total time:   0.003722
 Self time:   0.002182

count  total (s)   self (s)
   10   0.000562   0.000317   if !s:should_illuminate_file()
                                return
   10              0.000011   endif
                            
   10   0.001084   0.000301   if (s:previous_match !=# s:get_cur_word())
    7   0.000722   0.000210     call s:remove_illumination()
    3              0.000004   else
    3              0.000004     return
    7              0.000025   endif
                            
                              " Any delay at or below 17 milliseconds gets counted as no delay
    7              0.000071   if !has('timers') || g:Illuminate_delay <= 17
                                call s:illuminate()
                                return
    7              0.000009   endif
                            
    7              0.000037   if exists('s:timer_id') && s:timer_id > -1
                                call timer_stop(s:timer_id)
    7              0.000005   endif
                            
    7              0.000104   let s:timer_id = timer_start(g:Illuminate_delay, function('s:illuminate'))

FUNCTION  34()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 586
Called 26 times
Total time:   0.001122
 Self time:   0.000764

count  total (s)   self (s)
                            
   26   0.000841   0.000483     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
   26              0.000017     endif
                            
   26              0.000034     return '/'

FUNCTION  <SNR>132_PollCompletion()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 841
Called 62 times
Total time:   0.036130
 Self time:   0.004808

count  total (s)   self (s)
   62   0.020502   0.001573   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
   27              0.000674     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
   27              0.000080     return
   35              0.000060   endif
                            
   35   0.011576   0.000880   let s:completion = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
   35   0.002728   0.001031   call s:Complete()

FUNCTION  <SNR>124_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 164
Called 87 times
Total time:   0.011192
 Self time:   0.011192

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   87              0.000152   let res = ''
   87              0.000138   let i = -1
  522              0.000628   while i < 4
  435              0.000617     let i += 1
  435              0.001273     let item = get(a:list, i, '')
  435              0.000583     if item is ''
  132              0.000121       continue
  303              0.000214     endif
  303              0.000344     if i == 0
   87              0.000335       let res .= ' guifg='.item
  216              0.000244     elseif i == 1
   84              0.000215       let res .= ' guibg='.item
  132              0.000121     elseif i == 2
   57              0.000216       let res .= ' ctermfg='.item
   75              0.000084     elseif i == 3
   54              0.000145       let res .= ' ctermbg='.item
   21              0.000017     elseif i == 4
   21              0.000121       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  303              0.000213     endif
  390              0.000460   endwhile
   87              0.000141   return res

FUNCTION  40()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 721
Called 26 times
Total time:   0.004948
 Self time:   0.002235

count  total (s)   self (s)
   26              0.000121     let options = a:0 ? a:1 : {}
   26              0.000057     let toReturn = ""
                            
   26              0.000085     if has_key(options, 'format')
                                    let format = options['format']
                                    if has_key(self, '_strFor' . format)
                                        exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
   26              0.000028     else
   26   0.002771   0.000228         let toReturn = self._str()
   26              0.000026     endif
                            
   26   0.000649   0.000479     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
   26              0.000018     endif
                            
   26              0.000082     if has_key(options, 'truncateTo')
                                    let limit = options['truncateTo']
                                    if strdisplaywidth(toReturn) > limit-1
                                        while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
                                            let toReturn = substitute(toReturn, '^.', '', '')
                                        endwhile
                                        if len(split(toReturn, '/')) > 1
                                            let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
                                        endif
                                    endif
   26              0.000020     endif
                            
   26              0.000040     return toReturn

FUNCTION  45()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/path.vim line 816
Called 26 times
Total time:   0.002543
 Self time:   0.001144

count  total (s)   self (s)
   26   0.001347   0.000225     let l:separator = s:Path.Slash()
   26              0.000067     let l:leader = l:separator
                            
   26   0.000818   0.000541     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
   26              0.000019     endif
                            
   26              0.000171     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  <SNR>49_MRU_add_files_to_menu()
    Defined: ~/.vim/plugged/mru/plugin/mru.vim line 720
Called 8 times
Total time:   0.020953
 Self time:   0.017899

count  total (s)   self (s)
  128              0.000284     for fname in a:file_list
                                    " Escape special characters in the filename
  120              0.001284         let esc_fname = escape(fnamemodify(fname, ':t'), ".\\" . s:esc_filename_chars)
  120              0.000827         let esc_fname = substitute(esc_fname, '&', '&&', 'g')
                            
                                    " Truncate the directory name if it is long
  120              0.000530         let dir_name = fnamemodify(fname, ':h')
  120              0.000469         let len = strchars(dir_name)
                                    " Shorten long file names by adding only few characters from
                                    " the beginning and end.
  120              0.000243         if len > 30
  112              0.000943             let dir_name = strcharpart(dir_name, 0, 10) . '...' . strcharpart(dir_name, len - 20)
  120              0.000124         endif
  120              0.001473         let esc_dir_name = escape(dir_name, ".\\" . s:esc_filename_chars)
  120              0.000684         let esc_dir_name = substitute(esc_dir_name, '&', '&&', 'g')
                            
  120              0.000682 	let menu_path = '&File.&Recent\ Files.' . a:prefix . esc_fname . '\ (' . esc_dir_name . ')'
  120   0.006194   0.003140 	let esc_mfname = s:MRU_escape_filename(fname)
  120              0.004708         exe 'anoremenu <silent> ' . menu_path . " :call <SID>MRU_Edit_File('" . esc_mfname . "', 1)<CR>"
  120              0.001464 	exe 'tmenu ' . menu_path . ' Edit file ' . esc_mfname
  128              0.000251     endfor

FUNCTION  airline#extensions#tabline#get_buffer_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim line 182
Called 35 times
Total time:   0.008511
 Self time:   0.002692

count  total (s)   self (s)
   35   0.001406   0.001093   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
   35              0.000190   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
   35   0.006858   0.001352   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>49_MRU_LoadList()
    Defined: ~/.vim/plugged/mru/plugin/mru.vim line 130
Called 4 times
Total time:   0.014727
 Self time:   0.001468

count  total (s)   self (s)
                                " If the MRU file is present, then load the list of filenames. Otherwise
                                " start with an empty list.
    4              0.000090     if filereadable(g:MRU_File)
    4              0.000882         let s:MRU_files = readfile(g:MRU_File)
    4              0.000189         if s:MRU_files[0] =~# '^\s*" Most recently edited files in Vim'
                                        " Generated by the previous version of the MRU plugin.
                                        " Discard the list.
                                        let s:MRU_files = []
    4              0.000046         elseif s:MRU_files[0] =~# '^#'
                                        " Remove the comment line
    4              0.000027             call remove(s:MRU_files, 0)
                                    else
                                        " Unsupported format
                                        let s:MRU_files = []
    4              0.000003         endif
                                else
                                    let s:MRU_files = []
    4              0.000005     endif
                            
                                " Refresh the MRU menu with the latest list of filenames
    4   0.013407   0.000148     call s:MRU_Refresh_Menu()

FUNCTION  <SNR>138_skip()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy.vim line 173
Called 4 times
Total time:   0.000243
 Self time:   0.000243

count  total (s)   self (s)
    4              0.000058   if &diff || !filereadable(a:path)
                                return 1
    4              0.000003   endif
                            
    4              0.000014   if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, &filetype)
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help') && (&buftype == 'help')
                                  return 1
                                endif
    4              0.000003   endif
                            
    4              0.000016   if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
    4              0.000002   endif
                            
    4              0.000012   if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
    4              0.000004   endif
                            
    4              0.000008   return 0

FUNCTION  airline#async#vim_vcs_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim line 126
Called 16 times
Total time:   0.012241
 Self time:   0.012241

count  total (s)   self (s)
   16              0.000065     if g:airline#init#is_windows && &shell =~ 'cmd'
                                  let cmd = a:config['cmd'] . shellescape(a:file)
   16              0.000019     else
   16              0.000333       let cmd = ['sh', '-c', a:config['cmd'] . shellescape(a:file)]
   16              0.000019     endif
                            
   16              0.000223     let options = {'cfg': a:config, 'buf': '', 'file': a:file}
   16              0.000089     if has_key(s:untracked_jobs, a:file)
   12              0.000205       if job_status(get(s:untracked_jobs, a:file)) == 'run'
    9              0.000019         return
    3              0.000011       elseif has_key(s:untracked_jobs, a:file)
    3              0.000015         call remove(s:untracked_jobs, a:file)
    3              0.000003       endif
    7              0.000005     endif
    7              0.010802     let id = job_start(cmd, { 'err_io':   'out', 'out_cb':   function('s:on_stdout', options), 'close_cb': function('s:on_exit_untracked', options)})
    7              0.000166     let s:untracked_jobs[a:file] = id

FUNCTION  <SNR>110_get_hunks_signify()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 13
Called 94 times
Total time:   0.002777
 Self time:   0.002111

count  total (s)   self (s)
   94   0.002207   0.001541   let hunks = sy#repo#get_stats()
   94              0.000331   if hunks[0] >= 0
   94              0.000133     return hunks
                              endif
                              return []

FUNCTION  <SNR>146_GetMSL()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 744
Called 4 times
Total time:   0.015442
 Self time:   0.001829

count  total (s)   self (s)
                              " Start on the line we're at and use its indent.
    4              0.000016   let msl = a:lnum
    4   0.008450   0.000149   let lnum = s:PrevNonBlankNonString(a:lnum - 1)
    4              0.000009   while lnum > 0
                                " If we have a continuation line, or we're in a string, use line as MSL.
                                " Otherwise, terminate search as we have found our MSL already.
    4              0.000013     let line = getline(lnum)
                            
    4   0.000753   0.000200     if !s:Match(msl, s:backslash_continuation_regex) && s:Match(lnum, s:backslash_continuation_regex)
                                  " If the current line doesn't end in a backslash, but the previous one
                                  " does, look for that line's msl
                                  "
                                  " Example:
                                  "   foo = "bar" \
                                  "     "baz"
                                  "
                                  let msl = lnum
    4   0.000227   0.000067     elseif s:Match(msl, s:leading_operator_regex)
                                  " If the current line starts with a leading operator, keep its indent
                                  " and keep looking for an MSL.
                                  let msl = lnum
    4   0.000247   0.000060     elseif s:Match(lnum, s:splat_regex)
                                  " If the above line looks like the "*" of a splat, use the current one's
                                  " indentation.
                                  "
                                  " Example:
                                  "   Hash[*
                                  "     method_call do
                                  "       something
                                  "
                                  return msl
    4   0.000591   0.000065     elseif s:Match(lnum, s:non_bracket_continuation_regex) && s:Match(msl, s:non_bracket_continuation_regex)
                                  " If the current line is a non-bracket continuation and so is the
                                  " previous one, keep its indent and continue looking for an MSL.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two,
                                  "     three
                                  "
                                  let msl = lnum
    4   0.000352   0.000086     elseif s:Match(lnum, s:dot_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a dot, keep going to see if the previous line is the
                                  " start of another continuation.
                                  "
                                  " Example:
                                  "   parent.
                                  "     method_call {
                                  "     three
                                  "
                                  let msl = lnum
    4   0.000679   0.000084     elseif s:Match(lnum, s:non_bracket_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If the current line is a bracket continuation or a block-starter, but
                                  " the previous is a non-bracket one, respect the previous' indentation,
                                  " and stop here.
                                  "
                                  " Example:
                                  "   method_call one,
                                  "     two {
                                  "     three
                                  "
                                  return lnum
    4   0.000369   0.000098     elseif s:Match(lnum, s:bracket_continuation_regex) && (s:Match(msl, s:bracket_continuation_regex) || s:Match(msl, s:block_continuation_regex))
                                  " If both lines are bracket continuations (the current may also be a
                                  " block-starter), use the current one's and stop here
                                  "
                                  " Example:
                                  "   method_call(
                                  "     other_method_call(
                                  "       foo
                                  return msl
    4   0.001189   0.000107     elseif s:Match(lnum, s:block_regex) && !s:Match(msl, s:continuation_regex) && !s:Match(msl, s:block_continuation_regex)
                                  " If the previous line is a block-starter and the current one is
                                  " mostly ordinary, use the current one as the MSL.
                                  "
                                  " Example:
                                  "   method_call do
                                  "     something
                                  "     something_else
    1              0.000001       return msl
    3              0.000004     else
    3              0.000463       let col = match(line, s:continuation_regex) + 1
    3   0.001768   0.000096       if (col > 0 && !s:IsInStringOrComment(lnum, col)) || s:IsInString(lnum, strlen(line))
                                    let msl = lnum
    3              0.000004       else
    3              0.000005         break
                                  endif
                                endif
                            
                                let lnum = s:PrevNonBlankNonString(lnum - 1)
    3              0.000024   endwhile
    3              0.000008   return msl

FUNCTION  <SNR>132_AllowedToCompleteInBuffer()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 430
Called 118 times
Total time:   0.013147
 Self time:   0.012003

count  total (s)   self (s)
  118              0.001490   let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
  118              0.001257   if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
                                return 0
  118              0.000160   endif
                            
  118   0.004483   0.003339   if s:DisableOnLargeFile( a:buffer )
                                return 0
  118              0.000115   endif
                            
  118              0.001683   let whitelist_allows = type( g:ycm_filetype_whitelist ) != type( {} ) || has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
  118              0.000939   let blacklist_allows = type( g:ycm_filetype_blacklist ) != type( {} ) || !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
  118              0.000422   let allowed = whitelist_allows && blacklist_allows
  118              0.000215   if allowed
  118              0.000766     let s:previous_allowed_buffer_number = bufnr( a:buffer )
  118              0.000116   endif
  118              0.000242   return allowed

FUNCTION  <SNR>45_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim line 39
Called 16 times
Total time:   0.001668
 Self time:   0.001668

count  total (s)   self (s)
   16              0.000191   let s:active_winnr = winnr()
                            
   16              0.000085   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
   16              0.000024   endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   16              0.000492   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
   16              0.000693   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
   16              0.000033     return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()

FUNCTION  airline#extensions#tabline#add_label()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim line 226
Called 6 times
Total time:   0.000388
 Self time:   0.000159

count  total (s)   self (s)
    6              0.000042   if get(g:, 'airline#extensions#tabline#show_tab_type', 1)
    6   0.000322   0.000093     call a:dict.add_section_spaced('airline_tablabel', get(g:, 'airline#extensions#tabline#'.a:type.'_label', a:type))
    6              0.000009   endif

FUNCTION  <SNR>132_OnFileReadyToParse()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 595
Called 6 times
Total time:   0.016028
 Self time:   0.012699

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    6              0.000025   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    6   0.003505   0.000176   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
    5              0.012208     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
    5              0.000092     call timer_stop( s:pollers.file_parse_response.id )
    5              0.000107     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    6              0.000012   endif

FUNCTION  <SNR>124_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 95
Called 305 times
Total time:   0.005154
 Self time:   0.005154

count  total (s)   self (s)
  305              0.001746   if !hlexists(a:group)
                                return 0
  305              0.001798   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  305              0.000220   endif
  305              0.000331   return 1

FUNCTION  <SNR>132_OnInsertChar()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 648
Called 46 times
Total time:   0.012319
 Self time:   0.003819

count  total (s)   self (s)
   46   0.009583   0.001817   if !s:AllowedToCompleteInCurrentBuffer()
                                return
   46              0.000051   endif
                            
   46              0.000333   call timer_stop( s:pollers.completion.id )
   46   0.002160   0.001426   call s:CloseCompletionMenu()

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim line 100
Called 188 times
Total time:   0.003378
 Self time:   0.003378

count  total (s)   self (s)
  188              0.001534     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
  188              0.001564     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 11
Called 94 times
Total time:   0.000752
 Self time:   0.000752

count  total (s)   self (s)
   94              0.000259   if !a:0 || a:1 ==# -1
   94              0.000378     return get(b:, 'git_dir', '')
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>132_Complete()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 854
Called 73 times
Total time:   0.003430
 Self time:   0.002791

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
   73              0.000599   if s:completion.completion_start_column > s:completion.column || empty( s:completion.completions )
   57   0.001644   0.001143     call s:CloseCompletionMenu()
   16              0.000018   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects
                                " the first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim
                                " to deselect the first candidate and in turn preserve the user's current
                                " text until he explicitly chooses to replace it with a completion.
   16   0.000400   0.000262     call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
   73              0.000061   endif

FUNCTION  <SNR>146_AfterIndentKeyword()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 596
Called 4 times
Total time:   0.009182
 Self time:   0.000419

count  total (s)   self (s)
    4              0.000014   let info = a:pline_info
    4   0.008546   0.000090   let col = s:Match(info.plnum, s:ruby_indent_keywords)
                            
    4              0.000005   if col > 0
    4              0.000024     call cursor(info.plnum, col)
    4              0.000044     let ind = virtcol('.') - 1 + info.sw
                                " TODO: make this better (we need to count them) (or, if a searchpair
                                " fails, we know that something is lacking an end and thus we indent a
                                " level
    4   0.000355   0.000093     if s:Match(info.plnum, s:end_end_regex)
                                  let ind = indent('.')
    4   0.000116   0.000071     elseif s:IsAssignment(info.pline, col)
                                  if g:ruby_indent_assignment_style == 'hanging'
                                    " hanging indent
                                    let ind = col + info.sw - 1
                                  else
                                    " align with variable
                                    let ind = indent(info.plnum) + info.sw
                                  endif
    4              0.000002     endif
    4              0.000007     return ind
                              endif
                            
                              return -1

FUNCTION  <SNR>52_get_char()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim line 108
Called 1 time
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000005   let idx = col('.') - 1
    1              0.000003   if !a:0 || (a:0 && a:1 >= 0)
                                " Get char from cursor.
    1              0.000005     let line = getline('.')[idx :]
    1              0.000002     let pos = a:0 ? a:1 : 0
    1              0.000018     return matchstr(line, '^'.repeat('.', pos).'\zs.')
                              endif
                              " Get char behind cursor.
                              let line = getline('.')[: idx - 1]
                              let pos = 0 - (1 + a:1)
                              return matchstr(line, '.\ze'.repeat('.', pos).'$')

FUNCTION  airline#extensions#tabline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim line 227
Called 6 times
Total time:   0.000577
 Self time:   0.000260

count  total (s)   self (s)
    6   0.000479   0.000162   let builder = airline#builder#new(a:context)
    6              0.000020   let builder._build = builder.build
    6              0.000051   call extend(builder, s:prototype, 'force')
    6              0.000009   return builder

FUNCTION  airline#extensions#ale#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim line 72
Called 188 times
Total time:   0.053455
 Self time:   0.027043

count  total (s)   self (s)
  188              0.001172   if !exists(':ALELint')
                                return ''
  188              0.000150   endif
                            
  188              0.000861   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
  188              0.000786   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
  188              0.000733   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
  188              0.000799   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
  188              0.000528   let is_err = a:type ==# 'error'
                            
  188   0.007315   0.003937   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                return is_err ? '' : checking_symbol
  188              0.000153   endif
                            
  188              0.000605   let symbol = is_err ? error_symbol : warning_symbol
                            
  188   0.018613   0.003206   let counts = ale#statusline#Count(bufnr(''))
  188              0.001056   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
  188              0.000730     let errors = counts.error + counts.style_error
  188              0.000606     let num = is_err ? errors : counts.total - errors
                              else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
  188              0.000153   endif
                            
  188              0.000337   if show_line_numbers == 1
  188   0.016173   0.008546     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 36
Called 872 times
Total time:   0.011406
 Self time:   0.009369

count  total (s)   self (s)
  872   0.007566   0.005529   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  872              0.000691   endif
  872              0.001444   return a:text

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim line 10
Called 94 times
Total time:   0.001629
 Self time:   0.001629

count  total (s)   self (s)
   94              0.000830   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
   94              0.000686     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  sy#start()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy.vim line 9
Called 4 times
Total time:   0.009903
 Self time:   0.001543

count  total (s)   self (s)
    4              0.000015   if g:signify_locked
                                call sy#verbose('Locked.')
                                return
    4              0.000004   endif
                            
    4              0.000217   let sy_path = resolve(expand('%:p'))
    4              0.000030   if has('win32')
                                let sy_path = substitute(sy_path, '\v^(\w):\\\\', '\1:\\', '')
    4              0.000004   endif
                            
    4   0.000314   0.000071   if s:skip(sy_path)
                                call sy#verbose('Skip file: '. sy_path)
                                if exists('b:sy')
                                  call sy#sign#remove_all_signs(bufnr(''))
                                  unlet! b:sy
                                endif
                                return
    4              0.000002   endif
                            
    4              0.000030   if !exists('b:sy') || b:sy.path != sy_path
                                call sy#verbose('Register new file: '. sy_path)
                                let b:sy = { 'path':       sy_path, 'buffer':     bufnr(''), 'active':     0, 'detecting':  0, 'vcs':        [], 'hunks':      [], 'signid':     0x100, 'updated_by': '', 'stats':      [-1, -1, -1], 'info':       {    'dir':  fnamemodify(sy_path, ':p:h'),    'path': sy#util#escape(sy_path),    'file': sy#util#escape(fnamemodify(sy_path, ':t')) }}
                                if get(g:, 'signify_disable_by_default')
                                  call sy#verbose('Disabled by default.')
                                  return
                                endif
                                let b:sy.active = 1
                                call sy#repo#detect()
    4              0.000019   elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
    4              0.000008   elseif !b:sy.active
                                call sy#verbose('Inactive buffer.')
                                return
    4              0.000011   elseif empty(b:sy.vcs)
                                if get(b:sy, 'retry')
                                  let b:sy.retry = 0
                                  call sy#verbose('Redetecting VCS.')
                                  call sy#repo#detect()
                                else
                                  if get(b:sy, 'detecting')
                                    call sy#verbose('Detection is already in progress.')
                                  else
                                    call sy#verbose('No VCS found. Disabling.')
                                    call sy#disable()
                                  endif
                                endif
    4              0.000004   else
    8              0.000033     for vcs in b:sy.vcs
    4              0.000020       let job_id = get(b:, 'sy_job_id_'. vcs)
    4              0.000018       if type(job_id) != type(0) || job_id > 0
                                    call sy#verbose('Update is already in progress.', vcs)
    4              0.000003       else
    4   0.000141   0.000067         call sy#verbose('Updating signs.', vcs)
    4   0.008509   0.000466         call sy#repo#get_diff_start(vcs)
    4              0.000016       endif
    8              0.000099     endfor
    4              0.000005   endif

FUNCTION  <SNR>153_expand_cmd()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 327
Called 4 times
Total time:   0.000535
 Self time:   0.000302

count  total (s)   self (s)
    4              0.000016   let cmd = a:vcs_cmds[a:vcs]
    4   0.000263   0.000125   let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:vcs))
    4   0.000125   0.000077   let cmd = s:replace(cmd, '%d', s:difftool)
    4   0.000118   0.000071   let cmd = s:replace(cmd, '%n', s:devnull)
    4              0.000008   return cmd

FUNCTION  gutentags#statusline()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 654
Called 94 times
Total time:   0.010948
 Self time:   0.002294

count  total (s)   self (s)
   94   0.010135   0.001481     let l:modules_in_progress = gutentags#inprogress()
   94              0.000259     if empty(l:modules_in_progress)
   86              0.000118        return ''
    8              0.000009     endif
                            
    8              0.000018     let l:prefix = ''
    8              0.000014     let l:suffix = ''
    8              0.000015     if a:0 > 0
                                   let l:prefix = a:1
    8              0.000009     endif
    8              0.000010     if a:0 > 1
                                   let l:suffix = a:2
    8              0.000007     endif
                            
    8              0.000011     if a:0 > 2
                                   let l:genmsg = a:3
    8              0.000009     else
    8              0.000088        let l:genmsg = join(l:modules_in_progress, ',')
    8              0.000010     endif
                            
    8              0.000031     return l:prefix.l:genmsg.l:suffix

FUNCTION  airline#extensions#tabline#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim line 136
Called 29 times
Total time:   0.108546
 Self time:   0.002748

count  total (s)   self (s)
   29              0.000270   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
   29              0.000177   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
   29              0.000138   let curtabcnt = tabpagenr('$')
   29              0.000094   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
   29              0.000033   endif
                            
   29              0.000205   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline()
   29              0.000024   endif
   29              0.000048   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
   29              0.000123   elseif show_buffers && curtabcnt == 1 || !show_tabs
   29   0.106787   0.000989     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  <SNR>52_get()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim line 32
Called 22 times
Total time:   0.001078
 Self time:   0.001078

count  total (s)   self (s)
   22              0.000103   if a:0 == 2
                                return deepcopy(get(a:2, 'delimitMate_' . a:name, a:1))
   22              0.000056   elseif a:0 == 1
                                let bufoptions = get(s:options, bufnr('%'), {})
                                return deepcopy(get(bufoptions, a:name, a:1))
   22              0.000032   else
   22              0.000426     return deepcopy(eval('s:options.' . bufnr('%') . '.' . a:name))
                              endif

FUNCTION  gutentags#start_job()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 615
Called 4 times
Total time:   0.006346
 Self time:   0.006346

count  total (s)   self (s)
    4              0.006298         return job_start(a:cmd, a:opts)

FUNCTION  <SNR>52_is_forbidden()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim line 206
Called 3 times
Total time:   0.009234
 Self time:   0.000474

count  total (s)   self (s)
    3   0.000138   0.000098   if s:is_excluded_ft(&filetype)
                                return 1
    3              0.000003   endif
    3   0.000153   0.000049   if !s:get('excluded_regions_enabled')
                                return 0
    3              0.000004   endif
    3   0.008509   0.000119   let region = s:get_syn_name()
    3   0.000405   0.000179   return index(s:get('excluded_regions_list'), region) >= 0

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 50
Called 94 times
Total time:   0.029992
 Self time:   0.018565

count  total (s)   self (s)
   94              0.000531   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
   94              0.000794   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
   94              0.000126   endif
   94              0.000715   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
   94              0.000367   if !exists('b:airline_whitespace_check')
    4              0.000022     let b:airline_whitespace_check = ''
    4              0.000040     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    4              0.000007     let trailing = 0
    4              0.000011     let check = 'trailing'
    4              0.000106     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    4              0.000008       try
    4              0.000026         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    4              0.003671         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    4              0.000009       endtry
    4              0.000004     endif
                            
    4              0.000013     let mixed = 0
    4              0.000010     let check = 'indent'
    4              0.000096     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    4   0.006612   0.000150       let mixed = s:check_mixed_indent()
    4              0.000021     endif
                            
    4              0.000018     let mixed_file = ''
    4              0.000013     let check = 'mixed-indent-file'
    4              0.000122     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    4   0.000742   0.000179       let mixed_file = s:check_mixed_indent_file()
    4              0.000006     endif
                            
    4              0.000008     let long = 0
    4              0.000018     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    4              0.000005     endif
                            
    4              0.000023     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
    1              0.000005       let b:airline_whitespace_check = s:symbol
    1              0.000005       if strlen(s:symbol) > 0
    1              0.000006         let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
    1              0.000001       endif
                            
    1              0.000002       if s:show_message
    1              0.000002         if trailing != 0
    1              0.000007           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    1              0.000020           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    1              0.000001         endif
    1              0.000002         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
    1              0.000001         endif
    1              0.000002         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
    1              0.000001         endif
    1              0.000004         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
    1              0.000001         endif
    1              0.000001       endif
    4              0.000004     endif
   94              0.000073   endif
   94   0.006310   0.001908   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>134_should_illuminate_file()
    Defined: ~/.vim/plugged/vim-illuminate/autoload/illuminate.vim line 130
Called 12 times
Total time:   0.000311
 Self time:   0.000311

count  total (s)   self (s)
   12              0.000110   if !exists('g:Illuminate_ftblacklist')
                                let g:Illuminate_ftblacklist=['']
   12              0.000017   endif
                            
   12              0.000115   return index(g:Illuminate_ftblacklist, &filetype) < 0

FUNCTION  sy#util#chdir()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/util.vim line 85
Called 4 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    4              0.000042   let chdir = haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1, 0)) ? 'tcd' : 'cd'
    4              0.000019   return [getcwd(), chdir]

FUNCTION  airline#builder#get_next_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 49
Called 6 times
Total time:   0.000275
 Self time:   0.000275

count  total (s)   self (s)
    6              0.000029   let x = a:i + 1
    6              0.000026   let l = len(a:sections)
   12              0.000026   while x < l
   12              0.000063     let group = a:sections[x][0]
   12              0.000038     if group != '' && group != '|'
    6              0.000012       return group
    6              0.000006     endif
    6              0.000015     let x = x + 1
    6              0.000012   endwhile
                              return ''

FUNCTION  <SNR>153_callback_vim_close()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 35
Called 4 times
Total time:   0.001708
 Self time:   0.000306

count  total (s)   self (s)
    4              0.000023   let job = ch_getjob(a:channel)
    4              0.000010   while 1
    4              0.000062     if job_status(job) == 'dead'
    4              0.000051       let exitval = job_info(job).exitval
    4              0.000008       break
                                endif
                                sleep 10m
    4              0.000010   endwhile
    4   0.001511   0.000109   call s:job_exit(self.bufnr, self.vcs, exitval, self.stdoutbuf)

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 45
Called 94 times
Total time:   0.007338
 Self time:   0.004561

count  total (s)   self (s)
   94              0.000620   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
   94              0.000059   endif
   94   0.004987   0.002210   return {b:source_func}()

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 229
Called 7 times
Total time:   0.004819
 Self time:   0.000511

count  total (s)   self (s)
    7              0.000060   if getbufvar(a:bufnr, '&modified')
    3              0.000048     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    4              0.000006   else
    4              0.000082     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    7              0.000008   endif
                            
    7              0.000019   if !empty(colors)
    7   0.004524   0.000216     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    7              0.000005   endif

FUNCTION  <SNR>146_AccessModifier()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 284
Called 8 times
Total time:   0.000404
 Self time:   0.000404

count  total (s)   self (s)
    8              0.000030   let info = a:cline_info
                            
                              " If this line is an access modifier keyword, align according to the closest
                              " class declaration.
    8              0.000032   if g:ruby_indent_access_modifier_style == 'indent'
                                if s:Match(info.clnum, s:access_modifier_regex)
                                  let class_lnum = s:FindContainingClass()
                                  if class_lnum > 0
                                    return indent(class_lnum) + info.sw
                                  endif
                                endif
    8              0.000026   elseif g:ruby_indent_access_modifier_style == 'outdent'
                                if s:Match(info.clnum, s:access_modifier_regex)
                                  let class_lnum = s:FindContainingClass()
                                  if class_lnum > 0
                                    return indent(class_lnum)
                                  endif
                                endif
    8              0.000028   endif
                            
    8              0.000017   return -1

FUNCTION  <SNR>132_OnInsertLeave()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 736
Called 2 times
Total time:   0.016428
 Self time:   0.009448

count  total (s)   self (s)
    2   0.000373   0.000077   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    2              0.000002   endif
                            
    2              0.000016   call timer_stop( s:pollers.completion.id )
    2              0.000007   let s:force_semantic = 0
    2              0.000012   let s:completion = s:default_completion
                            
    2   0.006639   0.000075   call s:OnFileReadyToParse()
    2              0.008872   exec s:python_command "ycm_state.OnInsertLeave()"
    2              0.000055   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
    2   0.000431   0.000311     call s:ClosePreviewWindowIfNeeded()
    2              0.000003   endif

FUNCTION  <SNR>75_mysearchpair()
    Defined: ~/.vim/plugged/vim-endwise/plugin/endwise.vim line 132
Called 2 times
Total time:   0.010961
 Self time:   0.000589

count  total (s)   self (s)
    2              0.000009   let s:lastline = line('.')
    2   0.000063   0.000022   call s:synid()
    2   0.010880   0.000549   let line = searchpair(a:beginpat,'',a:endpat,'Wn','<SID>synid() !~# "^'.substitute(a:synidpat,'\\','\\\\','g').'$"',line('.')+50)
    2              0.000006   return line

FUNCTION  <SNR>111_update_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 83
Called 94 times
Total time:   0.022997
 Self time:   0.006494

count  total (s)   self (s)
   94   0.002471   0.001708   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
   94              0.000072   endif
                            
   94   0.016516   0.001997   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
   94   0.003098   0.001877   if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
   94              0.000076   endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 272
Called 94 times
Total time:   0.093883
 Self time:   0.008259

count  total (s)   self (s)
   94   0.082392   0.001928   let head = airline#extensions#branch#head()
   94   0.002789   0.002109   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
   94              0.000481   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
   94   0.006059   0.001579   let head = airline#util#shorten(head, winwidth, minwidth)
   94              0.000440   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
   94              0.000478   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   94              0.001022   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  <SNR>52_is_excluded_ft()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim line 199
Called 3 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    3              0.000028   if !exists("g:delimitMate_excluded_ft")
    3              0.000008     return 0
                              endif
                              return index(split(g:delimitMate_excluded_ft, ','), a:ft, 0, 1) >= 0

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim line 153
Called 52 times
Total time:   0.000635
 Self time:   0.000635

count  total (s)   self (s)
   52              0.000604     return has("win16") || has("win32") || has("win64")

FUNCTION  sy#set_signs()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy.vim line 85
Called 4 times
Total time:   0.000478
 Self time:   0.000286

count  total (s)   self (s)
    4   0.000107   0.000047   call sy#verbose('set_signs()', a:vcs)
                            
    4              0.000015   if a:sy.stats == [-1, -1, -1]
                                let a:sy.stats = [0, 0, 0]
    4              0.000003   endif
                            
    4              0.000008   if empty(a:diff)
    4   0.000096   0.000042     call sy#verbose('No changes found.', a:vcs)
    4              0.000022     let a:sy.stats = [0, 0, 0]
    4   0.000197   0.000119     call sy#sign#remove_all_signs(a:sy.buffer)
    4              0.000005     return
                              endif
                            
                              if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
                              else
                                call sy#highlight#line_disable()
                              endif
                            
                              call sy#sign#process_diff(a:sy, a:vcs, a:diff)
                            
                              if exists('#User#Signify')
                                execute 'doautocmd' (s:has_doau_modeline ? '<nomodeline>' : '') 'User Signify'
                              endif

FUNCTION  airline#extensions#tabline#group_of_bufnr()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim line 206
Called 18 times
Total time:   0.000710
 Self time:   0.000710

count  total (s)   self (s)
   18              0.000100   let cur = bufnr('%')
   18              0.000040   if cur == a:bufnr
   18              0.000164     if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
    9              0.000023       let group = 'airline_tabmod'
    9              0.000010     else
    9              0.000021       let group = 'airline_tabsel'
   18              0.000017     endif
                              else
                                if g:airline_detect_modified && getbufvar(a:bufnr, '&modified')
                                  let group = 'airline_tabmod_unsel'
                                elseif index(a:tab_bufs, a:bufnr) > -1
                                  let group = 'airline_tab'
                                else
                                  let group = 'airline_tabhid'
                                endif
   18              0.000020   endif
   18              0.000031   return group

FUNCTION  <SNR>132_OnCompleteDone()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 521
Called 16 times
Total time:   0.007067
 Self time:   0.005006

count  total (s)   self (s)
   16   0.002528   0.000467   if !s:AllowedToCompleteInCurrentBuffer()
                                return
   16              0.000011   endif
                            
   16              0.004471   exec s:python_command "ycm_state.OnCompleteDone()"

FUNCTION  285()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 33
Called 6 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    6              0.000026   return len(self._sections)

FUNCTION  <SNR>132_PollFileParseResponse()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 614
Called 5 times
Total time:   0.002392
 Self time:   0.001138

count  total (s)   self (s)
    5   0.001025   0.000100   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
    5              0.000008   endif
                            
    5              0.000765   exec s:python_command "ycm_state.HandleFileParseRequest()"
    5   0.000483   0.000154   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
    5              0.000004   endif

FUNCTION  gutentags#get_res_file()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 71
Called 4 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    4              0.000020     return g:gutentags_res_dir . a:filename

FUNCTION  FugitiveHead()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 89
Called 94 times
Total time:   0.014519
 Self time:   0.003510

count  total (s)   self (s)
   94   0.002252   0.001500   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
   94              0.000219   if empty(dir)
                                return ''
   94              0.000073   endif
   94   0.011717   0.001460   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  <SNR>146_ContinuedLine()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 468
Called 7 times
Total time:   0.014556
 Self time:   0.000794

count  total (s)   self (s)
    7              0.000023   let info = a:pline_info
                            
    7   0.002953   0.000138   let col = s:Match(info.plnum, s:ruby_indent_keywords)
    7   0.011332   0.000385   if s:Match(info.plnum, s:continuable_regex) && s:Match(info.plnum, s:continuation_regex)
                                if col > 0 && s:IsAssignment(info.pline, col)
                                  if g:ruby_indent_assignment_style == 'hanging'
                                    " hanging indent
                                    let ind = col - 1
                                  else
                                    " align with variable
                                    let ind = indent(info.plnum)
                                  endif
                                else
                                  let ind = indent(s:GetMSL(info.plnum))
                                endif
                                return ind + info.sw + info.sw
    7              0.000007   endif
    7              0.000017   return -1

FUNCTION  <SNR>153_get_diff_end()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 129
Called 4 times
Total time:   0.000714
 Self time:   0.000171

count  total (s)   self (s)
    4   0.000119   0.000054   call sy#verbose('get_diff_end()', a:vcs)
    4              0.000005   if a:found_diff
    4              0.000017     if index(a:sy.vcs, a:vcs) == -1
                                  let a:sy.vcs += [a:vcs]
    4              0.000004     endif
    4   0.000534   0.000056     call sy#set_signs(a:sy, a:vcs, a:diff)
                              else
                                call sy#verbose('No valid diff found. Disabling this VCS.', a:vcs)
    4              0.000004   endif

FUNCTION  delimitMate#ParenDelim()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim line 339
Called 2 times
Total time:   0.008275
 Self time:   0.000998

count  total (s)   self (s)
    2   0.000278   0.000108   let left = s:get('left_delims')[index(s:get('right_delims'),a:right)]
    2   0.006586   0.000069   if s:is_forbidden(a:right)
                                return left
    2              0.000004   endif
                              " Try to balance matchpairs
    2   0.000166   0.000066   if s:get('balance_matchpairs') && s:balance_matchpairs(a:right) < 0
                                return left
    2              0.000005   endif
    2              0.000018   let line = getline('.')
    2              0.000020   let col = col('.')-2
    2   0.000180   0.000070   if s:get('smart_matchpairs') != ''
    2   0.000232   0.000125     let smart_matchpairs = substitute(s:get('smart_matchpairs'), '\\!', left, 'g')
    2              0.000040     let smart_matchpairs = substitute(smart_matchpairs, '\\#', a:right, 'g')
    2              0.000074     if line[col+1:] =~ smart_matchpairs
                                  return left
    2              0.000005     endif
    2              0.000004   endif
    2   0.000257   0.000129   if len(line) == (col + 1) && s:get('insert_eol_marker') == 1
    2   0.000178   0.000083     let tail = s:get('eol_marker')
                              else
                                let tail = ''
    2              0.000003   endif
    2   0.000177   0.000127   return left . a:right . tail . repeat(s:joinUndo() . "\<Left>", len(split(tail, '\zs')) + 1)

FUNCTION  <SNR>146_AfterBlockOpening()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 490
Called 7 times
Total time:   0.015889
 Self time:   0.000615

count  total (s)   self (s)
    7              0.000046   let info = a:pline_info
                            
                              " If the previous line ended with a block opening, add a level of indent.
    7   0.003505   0.000158   if s:Match(info.plnum, s:block_regex)
    3              0.000012     if g:ruby_indent_block_style == 'do'
                                  " don't align to the msl, align to the "do"
                                  let ind = indent(info.plnum) + info.sw
    3              0.000005     else
    3   0.012034   0.000107       let plnum_msl = s:GetMSL(info.plnum)
                            
    3              0.000049       if getline(plnum_msl) =~ '=\s*\(#.*\)\=$'
                                    " in the case of assignment to the msl, align to the starting line,
                                    " not to the msl
                                    let ind = indent(info.plnum) + info.sw
    3              0.000002       else
    3              0.000022         let ind = indent(plnum_msl) + info.sw
    3              0.000004       endif
    3              0.000003     endif
                            
    3              0.000006     return ind
    4              0.000004   endif
                            
    4              0.000008   return -1

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 211
Called 94 times
Total time:   0.080464
 Self time:   0.006032

count  total (s)   self (s)
   94              0.000443   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
   94              0.000077   endif
                            
   94   0.045673   0.001765   call s:update_branch()
   94   0.032858   0.002334   call s:update_untracked()
                            
   94              0.000567   if exists('b:airline_head') && !empty(b:airline_head)
   94              0.000176     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let b:airline_head .= b:buffer_vcs_config[vcs].untracked
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '' : '.')
                                endif
                              endif
                            
                              return b:airline_head

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 110
Called 94 times
Total time:   0.007290
 Self time:   0.007290

count  total (s)   self (s)
   94              0.001003   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
   94              0.006056   return match(a:name, pat) > -1

FUNCTION  <SNR>132_CloseCompletionMenu()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 641
Called 103 times
Total time:   0.001235
 Self time:   0.001143

count  total (s)   self (s)
  103              0.000411   if pumvisible()
    8   0.000240   0.000148     call s:SendKeys( "\<C-e>" )
  103              0.000121   endif

FUNCTION  <SNR>75_crend()
    Defined: ~/.vim/plugged/vim-endwise/plugin/endwise.vim line 139
Called 2 times
Total time:   0.016742
 Self time:   0.005781

count  total (s)   self (s)
    2              0.000009   let n = ""
    2              0.000035   if !exists("b:endwise_addition") || !exists("b:endwise_words") || !exists("b:endwise_syngroups")
                                return n
    2              0.000002   endif
    2              0.000078   let synids = join(map(split(b:endwise_syngroups, ','), 'hlID(v:val)'), ',')
    2              0.000029   let wordchoice = '\%('.substitute(b:endwise_words,',','\\|','g').'\)'
    2              0.000009   if exists("b:endwise_pattern")
    2              0.000033     let beginpat = substitute(b:endwise_pattern,'&',substitute(wordchoice,'\\','\\&','g'),'g')
                              else
                                let beginpat = '\<'.wordchoice.'\>'
    2              0.000002   endif
    2              0.000011   let lnum = line('.') - 1
    2              0.000033   let space = matchstr(getline(lnum),'^\s*')
    2              0.000230   let col  = match(getline(lnum),beginpat) + 1
    2              0.000201   let word  = matchstr(getline(lnum),beginpat)
    2              0.000032   let endword = substitute(word,'.*',b:endwise_addition,'')
    2              0.000012   let y = n.endword."\<C-O>O"
    2              0.000008   if exists("b:endwise_end_pattern")
                                let endpat = '\w\@<!'.substitute(word, '.*', substitute(b:endwise_end_pattern, '\\', '\\\\', 'g'), '').'\w\@!'
    2              0.000021   elseif b:endwise_addition[0:1] ==# '\='
                                let endpat = '\w\@<!'.endword.'\w\@!'
    2              0.000002   else
    2              0.000021     let endpat = '\w\@<!'.substitute('\w\+', '.*', b:endwise_addition, '').'\w\@!'
    2              0.000003   endif
    2              0.000018   let synidpat  = '\%('.substitute(synids,',','\\|','g').'\)'
    2              0.000004   if a:always
                                return y
    2              0.004761   elseif col <= 0 || synID(lnum,col,1) !~ '^'.synidpat.'$'
                                return n
    2              0.000025   elseif getline('.') !~ '^\s*#\=$'
                                return n
    2              0.000002   endif
    2   0.011004   0.000043   let line = s:mysearchpair(beginpat,endpat,synidpat)
                              " even is false if no end was found, or if the end found was less
                              " indented than the current line
    2              0.000042   let even = strlen(matchstr(getline(line),'^\s*')) >= strlen(space)
    2              0.000006   if line == 0
                                let even = 0
    2              0.000013   endif
    2              0.000010   if !even && line == line('.') + 1
                                return y
    2              0.000002   endif
    2              0.000004   if even
    1              0.000002     return n
    1              0.000001   endif
    1              0.000003   return y

FUNCTION  <SNR>75_synid()
    Defined: ~/.vim/plugged/vim-endwise/plugin/endwise.vim line 188
Called 4 times
Total time:   0.010372
 Self time:   0.010372

count  total (s)   self (s)
                              " Checking this helps to force things to stay in sync
    8              0.000032   while s:lastline < line('.')
    4              0.007108     let s = synID(s:lastline,indent(s:lastline)+1,1)
    4              0.000038     let s:lastline = nextnonblank(s:lastline + 1)
    8              0.000022   endwhile
                            
    4              0.003098   let s = synID(line('.'),col('.'),1)
    4              0.000025   let s:lastline = line('.')
    4              0.000009   return s

FUNCTION  <SNR>132_InsideCommentOrStringAndShouldStop()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 799
Called 40 times
Total time:   0.070896
 Self time:   0.001423

count  total (s)   self (s)
   40   0.070317   0.000844   let retval = s:InsideCommentOrString()
   40              0.000116   let inside_comment = retval == 1
   40              0.000076   let inside_string = retval == 2
                            
   40              0.000143   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
   40              0.000026   endif
                            
   40              0.000057   return retval

FUNCTION  <SNR>146_ClosingHeredocDelimiter()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 396
Called 7 times
Total time:   0.000172
 Self time:   0.000172

count  total (s)   self (s)
    7              0.000022   let info = a:cline_info
                            
                              " If we are at the closing delimiter of a "<<" heredoc-style string, set the
                              " indent to 0.
    7              0.000102   if info.cline =~ '^\k\+\s*$' && s:IsInStringDelimiter(info.clnum, 1) && search('\V<<'.info.cline, 'nbW') > 0
                                return 0
    7              0.000003   endif
                            
    7              0.000009   return -1

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 37
Called 60 times
Total time:   0.001949
 Self time:   0.001949

count  total (s)   self (s)
   60              0.000707   let x = a:i - 1
   72              0.000158   while x >= 0
   54              0.000203     let group = a:sections[x][0]
   54              0.000310     if group != '' && group != '|'
   42              0.000076       return group
   12              0.000013     endif
   12              0.000030     let x = x - 1
   30              0.000087   endwhile
   18              0.000027   return ''

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 269
Called 15 times
Total time:   0.000186
 Self time:   0.000186

count  total (s)   self (s)
   15              0.000106   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   15              0.000017   endif

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 49
Called 188 times
Total time:   0.001262
 Self time:   0.001262

count  total (s)   self (s)
  188              0.001130   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 63
Called 94 times
Total time:   0.000420
 Self time:   0.000420

count  total (s)   self (s)
   94              0.000355   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  rubycomplete#Complete()
    Defined: ~/.vim/plugged/vim-ruby/autoload/rubycomplete.vim line 217
Called 4 times
Total time:   0.006589
 Self time:   0.006589

count  total (s)   self (s)
                                 "findstart = 1 when we need to get the text length
    4              0.000017     if a:findstart
    2              0.000018         let line = getline('.')
    2              0.000008         let idx = col('.')
    2              0.000006         while idx > 0
    2              0.000005             let idx -= 1
    2              0.000014             let c = line[idx-1]
    2              0.000024             if c =~ '\w'
                                            continue
    2              0.000011             elseif ! c =~ '\.'
                                            let idx = -1
                                            break
    2              0.000002             else
    2              0.000003                 break
                                        endif
    2              0.000006         endwhile
                            
    2              0.000005         return idx
                                "findstart = 0 when we need to return the list of completions
    2              0.000002     else
    2              0.000197         let g:rubycomplete_completions = []
    2              0.006179         execute "ruby VimRubyCompletion.get_completions('" . a:base . "')"
    2              0.000010         return g:rubycomplete_completions
                                endif

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/.vim/plugged/ultisnips/autoload/UltiSnips.vim line 146
Called 86 times
Total time:   0.029042
 Self time:   0.029042

count  total (s)   self (s)
   86              0.028882     exec g:_uspy "UltiSnips_Manager._track_change()"

FUNCTION  <SNR>52_get_syn_name()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim line 191
Called 3 times
Total time:   0.008390
 Self time:   0.008390

count  total (s)   self (s)
    3              0.000031   let col = col('.')
    3              0.000014   if  col == col('$')
    2              0.000008     let col = col - 1
    3              0.000004   endif
    3              0.008314   return synIDattr(synIDtrans(synID(line('.'), col, 1)), 'name')

FUNCTION  <SNR>132_InvokeCompletion()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 818
Called 38 times
Total time:   0.238692
 Self time:   0.121297

count  total (s)   self (s)
   38   0.216655   0.119141   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
   38   0.021920   0.002039   call s:PollCompletion()

FUNCTION  <SNR>146_StartOfFile()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 434
Called 7 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
                              " At the start of the file use zero indent.
    7              0.000025   if a:pline_info.plnum == 0
                                return 0
    7              0.000009   endif
    7              0.000009   return -1

FUNCTION  ale#events#SaveEvent()
    Defined: ~/.vim/plugged/ale/autoload/ale/events.vim line 25
Called 4 times
Total time:   0.000415
 Self time:   0.000217

count  total (s)   self (s)
    4   0.000203   0.000070     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    4              0.000007     if l:should_lint
                                    call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    4              0.000004     endif
                            
    4   0.000112   0.000047     if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
                                    let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
    4              0.000003     endif
                            
    4              0.000012     if l:should_lint && !ale#events#QuitRecently(a:buffer)
                                    call ale#Queue(0, 'lint_file', a:buffer)
    4              0.000003     endif

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 89
Called 120 times
Total time:   0.011206
 Self time:   0.003916

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  120   0.009843   0.002553   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
   26              0.000037     return ''
   94              0.000079   endif
   94              0.000311   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
   94              0.000072   else
   94              0.000217     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 324
Called 94 times
Total time:   0.010257
 Self time:   0.010257

count  total (s)   self (s)
   94              0.000635   let dir = a:0 > 1 ? a:2 : s:Dir()
   94              0.002788   if empty(dir) || !filereadable(dir . '/HEAD')
                                return ''
   94              0.000126   endif
   94              0.002585   let head = readfile(dir . '/HEAD')[0]
   94              0.001448   if head =~# '^ref: '
   94              0.002252     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>132_SendKeys()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 629
Called 24 times
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
                              " By default keys are added to the end of the typeahead buffer. If there are
                              " already keys in the buffer, they will be processed first and may change the
                              " state that our keys combination was sent for (e.g. <C-X><C-U><C-P> in normal
                              " mode instead of insert mode or <C-e> outside of completion mode). We avoid
                              " that by inserting the keys at the start of the typeahead buffer with the 'i'
                              " option. Also, we don't want the keys to be remapped to something else so we
                              " add the 'n' option.
   24              0.000147   call feedkeys( a:keys, 'in' )

FUNCTION  <SNR>134_get_cur_word()
    Defined: ~/.vim/plugged/vim-illuminate/autoload/illuminate.vim line 104
Called 20 times
Total time:   0.001266
 Self time:   0.001266

count  total (s)   self (s)
   20              0.000141   let line = getline('.')
   20              0.000137   let col = col('.') - 1
   20              0.000122   let left_part = strpart(line, 0, col + 1)
   20              0.000116   let right_part = strpart(line, col, col('$'))
   20              0.000573   let word = matchstr(left_part, '\k*$') . matchstr(right_part, '^\k*')[1:]
                            
   20              0.000125   return '\<' . escape(word, '/\?') . '\>'

FUNCTION  nerdtree#has_opt()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim line 121
Called 26 times
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
   26              0.000151     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  gutentags#get_project_info()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 230
Called 4 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    4              0.000044     return get(s:known_projects, a:path, {})

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 130
Called 24 times
Total time:   0.014619
 Self time:   0.002181

count  total (s)   self (s)
   24              0.000109   if a:group1 == a:group2
                                return 0
   24              0.000026   endif
   24   0.008346   0.001042   let color1 = airline#highlighter#get_highlight(a:group1)
   24   0.005797   0.000663   let color2 = airline#highlighter#get_highlight(a:group2)
   24              0.000051   if g:airline_gui_mode ==# 'gui'
   24              0.000175     return color1[1] != color2[1] || color1[0] != color2[0]
                              else
                                return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  289()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim line 96
Called 6 times
Total time:   0.083706
 Self time:   0.003303

count  total (s)   self (s)
    6              0.000045   if has_key(self, '_left_position') && self._first_title <= self._last_title
    6   0.030441   0.000340     let self._remaining_space = &columns - s:tabline_evaluated_length(self._build())
                            
    6              0.000046     let center_active = get(g:, 'airline#extensions#tabline#center_active', 0)
                            
    6   0.001234   0.000235     let sep_size = s:tabline_evaluated_length(self._context.left_sep)
    6   0.000914   0.000208     let alt_sep_size = s:tabline_evaluated_length(self._context.left_alt_sep)
                            
    6   0.000334   0.000161     let outer_left_group = airline#builder#get_prev_group(self._sections, self._left_position)
    6   0.000494   0.000219     let outer_right_group = airline#builder#get_next_group(self._sections, self._right_position)
                            
    6              0.000050     let overflow_marker = get(g:, 'airline#extensions#tabline#overflow_marker', g:airline_symbols.ellipsis)
    6   0.000868   0.000200     let overflow_marker_size = s:tabline_evaluated_length(overflow_marker)
                                " Allow space for the markers before we begin filling in titles.
    6              0.000022     if self._left_title > self._first_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_left_group, sep_size, alt_sep_size)
    6              0.000007     endif
    6              0.000013     if self._left_title < self._last_title
                                  let self._remaining_space -= overflow_marker_size + s:get_separator_change(self.overflow_group, "", outer_right_group, sep_size, alt_sep_size)
    6              0.000007     endif
                            
                                " Add the current title
    6   0.000753   0.000072     let group = self.get_group(self._left_title)
    6              0.000017     if self._left_title == self._first_title
    6   0.000621   0.000194       let sep_change = s:get_separator_change(group, "", outer_left_group, sep_size, alt_sep_size)
                                else
                                  let sep_change = s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    6              0.000006     endif
    6              0.000016     if self._left_title == self._last_title
    6   0.004932   0.000180       let sep_change += s:get_separator_change(group, "", outer_right_group, sep_size, alt_sep_size)
                                else
                                  let sep_change += s:get_separator_change(group, "", self.overflow_group, sep_size, alt_sep_size)
    6              0.000007     endif
    6              0.000015     let left_group = group
    6              0.000015     let right_group = group
    6   0.005941   0.000102     let self._left_title -= self.try_insert_title(self._left_title, group, self._left_position, sep_change, 1)
                            
    6              0.000026     if get(g:, 'airline#extensions#tabline#current_first', 0)
                                  " always have current title first
                                  let self._left_position += 1
    6              0.000005     endif
                            
    6              0.000021     if !center_active && self._right_title <= self._last_title
                                  " Add the title to the right
                                  let group = self.get_group(self._right_title)
                                  if self._right_title == self._last_title
                                    let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                  else
                                    let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                  endif
                                  let right_group = group
                                  let self._right_title += self.try_insert_title(self._right_title, group, self._right_position, sep_change, 1)
    6              0.000007     endif
                            
    6              0.000017     while self._remaining_space > 0
    6              0.000011       let done = 0
    6              0.000013       if self._left_title >= self._first_title
                                    " Insert next title to the left
                                    let group = self.get_group(self._left_title)
                                    if self._left_title == self._first_title
                                      let sep_change = s:get_separator_change_with_end(group, left_group, outer_left_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, left_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let left_group = group
                                    let done = self.try_insert_title(self._left_title, group, self._left_position, sep_change, 0)
                                    let self._left_title -= done
    6              0.000004       endif
                                  " If center_active is set, this |if| operates as an independent |if|,
                                  " otherwise as an |elif|.
    6              0.000019       if self._right_title <= self._last_title && (center_active || !done)
                                    " Insert next title to the right
                                    let group = self.get_group(self._right_title)
                                    if self._right_title == self._last_title
                                      let sep_change = s:get_separator_change_with_end(group, right_group, outer_right_group, self.overflow_group, sep_size, alt_sep_size) - overflow_marker_size
                                    else
                                      let sep_change = s:get_separator_change(group, right_group, self.overflow_group, sep_size, alt_sep_size)
                                    endif
                                    let right_group = group
                                    let done = self.try_insert_title(self._right_title, group, self._right_position, sep_change, 0)
                                    let self._right_title += done
    6              0.000008       endif
    6              0.000008       if !done
    6              0.000011         break
                                  endif
    6              0.000018     endwhile
                            
    6              0.000012     if self._left_title >= self._first_title
                                  if get(g:, 'airline#extensions#tabline#current_first', 0)
                                    let self._left_position -= 1
                                  endif
                                  call self.insert_section(self.overflow_group, overflow_marker, self._left_position)
                                  let self._right_position += 1
    6              0.000006     endif
                            
    6              0.000014     if self._right_title <= self._last_title
                                  call self.insert_section(self.overflow_group, overflow_marker, self._right_position)
    6              0.000005     endif
    6              0.000007   endif
                            
    6   0.035867   0.000085   return self._build()

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 104
Called 392 times
Total time:   0.139493
 Self time:   0.043624

count  total (s)   self (s)
  392              0.001052   if pumvisible()
                                return
  392              0.000275   endif
  392              0.000823   let colors = a:colors
  392              0.000609   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  392              0.000277   endif
  392   0.077247   0.008467   let old_hi = airline#highlighter#get_highlight(a:group)
  392              0.001061   if len(colors) == 4
  166              0.000583     call add(colors, '')
  392              0.000276   endif
  392              0.000640   if g:airline_gui_mode ==# 'gui'
  392              0.002232     let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  392              0.000289   endif
  392   0.017720   0.006977   let colors = s:CheckDefined(colors)
  392   0.011477   0.006323   if old_hi != new_hi || !s:hl_group_exists(a:group)
   87   0.012842   0.001650     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   87              0.001386     exe cmd
   87              0.000334     if has_key(s:hl_groups, a:group)
   87              0.000287       let s:hl_groups[a:group] = colors
   87              0.000068     endif
  392              0.000241   endif

FUNCTION  <SNR>132_IdentifierFinishedOperations()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 770
Called 40 times
Total time:   0.015751
 Self time:   0.010613

count  total (s)   self (s)
   40   0.005769   0.000631   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
   32              0.000066     return
    8              0.000007   endif
    8              0.009725   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
    8              0.000075   let s:force_semantic = 0
    8              0.000032   let s:completion = s:default_completion

FUNCTION  GetRubyIndent()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 164
Called 8 times
Total time:   0.110055
 Self time:   0.006176

count  total (s)   self (s)
                              " 2.1. Setup {{{2
                              " ----------
                            
    8              0.000050   let indent_info = {}
                            
                              " The value of a single shift-width
    8              0.000054   if exists('*shiftwidth')
    8              0.000043     let indent_info.sw = shiftwidth()
                              else
                                let indent_info.sw = &sw
    8              0.000013   endif
                            
                              " For the current line, use the first argument if given, else v:lnum
    8              0.000036   let indent_info.clnum = a:0 ? a:1 : v:lnum
    8              0.000044   let indent_info.cline = getline(indent_info.clnum)
                            
                              " Set up variables for restoring position in file.  Could use clnum here.
    8              0.000034   let indent_info.col = col('.')
                            
                              " 2.2. Work on the current line {{{2
                              " -----------------------------
    8              0.000083   let indent_callback_names = [ 's:AccessModifier', 's:ClosingBracketOnEmptyLine', 's:BlockComment', 's:DeindentingKeyword', 's:MultilineStringOrLineComment', 's:ClosingHeredocDelimiter', 's:LeadingOperator', ]
                            
   60              0.000142   for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
   53   0.024958   0.001707     let indent = call(function(callback_name), [indent_info])
                            
   53              0.000085     if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
    1              0.000001       return indent
   52              0.000042     endif
   59              0.000079   endfor
                            
                              " 2.3. Work on the previous line. {{{2
                              " -------------------------------
                            
                              " Special case: we don't need the real s:PrevNonBlankNonString for an empty
                              " line inside a string. And that call can be quite expensive in that
                              " particular situation.
    7              0.000028   let indent_callback_names = [ 's:EmptyInsideString', ]
                            
   14              0.000037   for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
    7   0.008028   0.000243     let indent = call(function(callback_name), [indent_info])
                            
    7              0.000016     if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
    7              0.000009     endif
   14              0.000022   endfor
                            
                              " Previous line number
    7   0.020723   0.000297   let indent_info.plnum = s:PrevNonBlankNonString(indent_info.clnum - 1)
    7              0.000037   let indent_info.pline = getline(indent_info.plnum)
                            
    7              0.000066   let indent_callback_names = [ 's:StartOfFile', 's:AfterAccessModifier', 's:ContinuedLine', 's:AfterBlockOpening', 's:AfterHangingSplat', 's:AfterUnbalancedBracket', 's:AfterLeadingOperator', 's:AfterEndKeyword', 's:AfterIndentKeyword', ]
                            
   48              0.000175   for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
   48   0.054284   0.001867     let indent = call(function(callback_name), [indent_info])
                            
   48              0.000096     if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
    7              0.000011       return indent
   41              0.000039     endif
   41              0.000092   endfor
                            
                              " 2.4. Work on the MSL line. {{{2
                              " --------------------------
                              let indent_callback_names = [ 's:PreviousNotMSL', 's:IndentingKeywordInMSL', 's:ContinuedHangingOperator', ]
                            
                              " Most Significant line based on the previous one -- in case it's a
                              " contination of something above
                              let indent_info.plnum_msl = s:GetMSL(indent_info.plnum)
                            
                              for callback_name in indent_callback_names
                            "    Decho "Running: ".callback_name
                                let indent = call(function(callback_name), [indent_info])
                            
                                if indent >= 0
                            "      Decho "Match: ".callback_name." indent=".indent." info=".string(indent_info)
                                  return indent
                                endif
                              endfor
                            
                              " }}}2
                            
                              " By default, just return the previous line's indent
                            "  Decho "Default case matched"
                              return indent(indent_info.plnum)

FUNCTION  sy#repo#get_stats()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 227
Called 94 times
Total time:   0.000666
 Self time:   0.000666

count  total (s)   self (s)
   94              0.000589   return exists('b:sy') ? b:sy.stats : [-1, -1, -1]

FUNCTION  <SNR>154_on_exit_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim line 69
Called 7 times
Total time:   0.000565
 Self time:   0.000313

count  total (s)   self (s)
    7   0.000471   0.000219     call s:untracked_output(self, self.buf)
    7              0.000037     if has_key(s:untracked_jobs, self.file)
    4              0.000023       call remove(s:untracked_jobs, self.file)
    7              0.000010     endif

FUNCTION  <SNR>136_tabline_evaluated_length()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim line 223
Called 30 times
Total time:   0.007784
 Self time:   0.001686

count  total (s)   self (s)
   30   0.007763   0.001665   return airline#util#strchars(s:evaluate_tabline(a:tabline))

FUNCTION  <SNR>127_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 166
Called 42 times
Total time:   0.002860
 Self time:   0.002860

count  total (s)   self (s)
   42              0.000129   if a:self._context.active
                                " active window
   42              0.000106     let contents = []
   42              0.000543     let content_parts = split(a:contents, '__accent')
   60              0.000165     for cpart in content_parts
   18              0.000265       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   18              0.000103       call add(contents, cpart)
   60              0.000126     endfor
   42              0.000221     let line = join(contents, a:group)
   42              0.000406     let line = substitute(line, '__restore__', a:group, 'g')
                              else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
   42              0.000034   endif
   42              0.000078   return line

FUNCTION  <SNR>49_MRU_SaveList()
    Defined: ~/.vim/plugged/mru/plugin/mru.vim line 156
Called 4 times
Total time:   0.033947
 Self time:   0.033947

count  total (s)   self (s)
    4              0.000012     let l = []
    4              0.000020     call add(l, '# Most recently edited files in Vim (version 3.0)')
    4              0.000093     call extend(l, s:MRU_files)
    4              0.033802     call writefile(l, g:MRU_File)

FUNCTION  <SNR>74_StopHL()
    Defined: ~/.vim/plugged/vim-cool/plugin/cool.vim line 76
Called 2 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000015     if !v:hlsearch || mode() isnot 'n'
    2              0.000006         return
                                else
                                    silent call feedkeys("\<Plug>(StopHL)", 'm')
                                endif

FUNCTION  <SNR>151_get_ctags_executable()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags/ctags.vim line 193
Called 4 times
Total time:   0.000389
 Self time:   0.000337

count  total (s)   self (s)
                                "Only consider the main filetype in cases like 'python.django'
    4              0.000095     let l:ftype = get(split(&filetype, '\.'), 0, '')
    4   0.000168   0.000116     let l:proj_info = gutentags#get_project_info(a:proj_dir)
    4              0.000021     let l:type = get(l:proj_info, 'type', l:ftype)
    4              0.000043     let exepath = exists('g:gutentags_ctags_executable_{l:type}') ? g:gutentags_ctags_executable_{l:type} : g:gutentags_ctags_executable
    4              0.000041     return expand(exepath, 1)

FUNCTION  <SNR>124_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 189
Called 160 times
Total time:   0.130209
 Self time:   0.014305

count  total (s)   self (s)
  160              0.000530   if pumvisible()
                                return
  160              0.000121   endif
  160              0.000635   let group = a:from.'_to_'.a:to.a:suffix
  160   0.036617   0.003254   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  160   0.033747   0.003212   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  160              0.000225   if a:inverse
   56              0.000357     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  104              0.000081   else
  104              0.000684     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  160              0.000134   endif
  160              0.000718   let a:dict[group] = colors
  160   0.055321   0.003315   call airline#highlighter#exec(group, colors)

FUNCTION  <SNR>124_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 56
Called 760 times
Total time:   0.008259
 Self time:   0.008259

count  total (s)   self (s)
  760              0.003512   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  760              0.004194   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  <SNR>51_TriggerAbb()
    Defined: ~/.vim/plugged/delimitMate/plugin/delimitMate.vim line 262
Called 3 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
    3              0.000109   if v:version < 703 || ( v:version == 703 && !has('patch489') ) || pumvisible()
    2              0.000012     return ''
    1              0.000003   endif
    1              0.000009   return "\<C-]>"

FUNCTION  <SNR>49_MRU_escape_filename()
    Defined: ~/.vim/plugged/mru/plugin/mru.vim line 246
Called 128 times
Total time:   0.003256
 Self time:   0.003256

count  total (s)   self (s)
  128              0.000581     if exists("*fnameescape")
  128              0.002524         return fnameescape(a:fname)
                                else
                                    return escape(a:fname, s:esc_filename_chars)
                                endif

FUNCTION  <SNR>146_IsInStringOrDocumentation()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 702
Called 7 times
Total time:   0.013026
 Self time:   0.000176

count  total (s)   self (s)
    7   0.013017   0.000167   return s:IsInRubyGroup(s:syng_stringdoc, a:lnum, a:col)

FUNCTION  <SNR>151_generate_wildignore_options()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags/ctags.vim line 203
Called 4 times
Total time:   0.000180
 Self time:   0.000134

count  total (s)   self (s)
    4              0.000025     if s:last_wildignores == &wildignore
                                    " The 'wildignore' setting didn't change since last time we did this.
    4   0.000129   0.000083         call gutentags#trace("Wildignore options file is up to date.")
    4              0.000008         return
                                endif
                            
                                if s:wildignores_options_path == ''
                                    if empty(g:gutentags_cache_dir)
                                        let s:wildignores_options_path = tempname()
                                    else
                                        let s:wildignores_options_path = gutentags#stripslash(g:gutentags_cache_dir).'/_wildignore.options'
                                    endif
                                endif
                            
                                call gutentags#trace("Generating wildignore options: ".s:wildignores_options_path)
                                let l:opt_lines = []
                                for ign in split(&wildignore, ',')
                                    call add(l:opt_lines, ign)
                                endfor
                                call writefile(l:opt_lines, s:wildignores_options_path)
                                let s:last_wildignores = &wildignore

FUNCTION  <SNR>153_job_exit()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 48
Called 4 times
Total time:   0.001402
 Self time:   0.000334

count  total (s)   self (s)
    4   0.000167   0.000068   call sy#verbose('job_exit()', a:vcs)
    4              0.000027   let sy = getbufvar(a:bufnr, 'sy')
    4              0.000010   if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:bufnr)), a:vcs)
                                return
    4              0.000020   elseif !empty(sy.updated_by) && sy.updated_by != a:vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:vcs)
                                return
    4              0.000013   elseif empty(sy.vcs) && sy.active
                                let sy.detecting -= 1
    4              0.000004   endif
    4   0.001070   0.000101   call sy#repo#get_diff_{a:vcs}(sy, a:exitval, a:diff)
    4              0.000025   call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, 0)

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 67
Called 94 times
Total time:   0.003811
 Self time:   0.003811

count  total (s)   self (s)
   94              0.001871   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
   94              0.000273   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
   94              0.000070   endif
   94              0.000113   return ''

FUNCTION  <SNR>127_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 143
Called 30 times
Total time:   0.035014
 Self time:   0.002199

count  total (s)   self (s)
   30              0.000080   let line = ''
   30              0.000256   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   30              0.000029   else
   30   0.033695   0.000880     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   30              0.000220     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   30              0.000179     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   30              0.000092     let line .= '%#'.a:group.'#'
   30              0.000026   endif
   30              0.000053   return line

FUNCTION  <SNR>127_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 185
Called 54 times
Total time:   0.001100
 Self time:   0.001100

count  total (s)   self (s)
   54              0.000148   let start=1
                            
                              " do not check for inactive windows or the tabline
   54              0.000149   if a:self._context.active == 0
                                return 0
   54              0.000223   elseif get(a:self._context, 'tabline', 0)
   54              0.000332     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(g:, 'airline_skip_empty_sections', 0) == 0
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>133_write_triggered_update_tags()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 450
Called 4 times
Total time:   0.015229
 Self time:   0.000596

count  total (s)   self (s)
    4              0.000019     if g:gutentags_enabled && g:gutentags_generate_on_write
    8              0.000046         for module in g:gutentags_modules
    4   0.014626   0.000269             call s:update_tags(a:bufno, module, 0, 2)
    8              0.000031         endfor
    4              0.000006     endif
    4   0.000430   0.000154     silent doautocmd User GutentagsUpdating

FUNCTION  <SNR>146_IsInRubyGroup()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 686
Called 57 times
Total time:   0.078236
 Self time:   0.078236

count  total (s)   self (s)
   57              0.003810   let ids = map(copy(a:groups), 'hlID("ruby".v:val)')
   57              0.074334   return index(ids, synID(a:lnum, a:col, 1)) >= 0

FUNCTION  airline#extensions#tabline#formatters#default#format()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim line 12
Called 35 times
Total time:   0.005506
 Self time:   0.004304

count  total (s)   self (s)
   35              0.000184   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':~:.')
   35              0.000057   let _ = ''
                            
   35              0.000183   let name = bufname(a:bufnr)
   35              0.000094   if empty(name)
                                let _ .= '[No Name]'
   35              0.000041   else
   35              0.000064     if s:fnamecollapse
                                  " Does not handle non-ascii characters like Cyrillic: 'D//t.c'
                                  "let _ .= substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g')
   35              0.001460       let _ .= pathshorten(fnamemodify(name, fmod))
                                else
                                  let _ .= fnamemodify(name, fmod)
   35              0.000035     endif
   35              0.000232     if a:bufnr != bufnr('%') && s:fnametruncate && strlen(_) > s:fnametruncate
                                  let _ = strpart(_, 0, s:fnametruncate)
   35              0.000026     endif
   35              0.000030   endif
                            
   35   0.002588   0.001386   return airline#extensions#tabline#formatters#default#wrap_name(a:bufnr, _)

FUNCTION  <SNR>114_check_mixed_indent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 15
Called 4 times
Total time:   0.006462
 Self time:   0.006462

count  total (s)   self (s)
    4              0.000036   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    4              0.000009   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    4              0.000009   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
    4              0.000004   else
    4              0.006313     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  sy#sign#remove_all_signs()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/sign.vim line 220
Called 4 times
Total time:   0.000078
 Self time:   0.000078

count  total (s)   self (s)
    4              0.000026   let sy = getbufvar(a:bufnr, 'sy')
                            
    4              0.000010   for hunk in sy.hunks
                                for id in hunk.ids
                                  execute 'sign unplace' id 'buffer='.a:bufnr
                                endfor
    4              0.000004   endfor
                            
    4              0.000009   let sy.hunks = []

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 59
Called 94 times
Total time:   0.000758
 Self time:   0.000758

count  total (s)   self (s)
   94              0.000687   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  <SNR>52_joinUndo()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim line 659
Called 2 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    2              0.000022   if v:version < 704 || ( v:version == 704 && !has('patch849') )
                                return ''
    2              0.000004   endif
    2              0.000014   return "\<C-G>U"

FUNCTION  <SNR>91_Highlight_Matching_Pair()
    Defined: /usr/local/share/vim/vim81/plugin/matchparen.vim line 39
Called 94 times
Total time:   0.054811
 Self time:   0.054811

count  total (s)   self (s)
                              " Remove any previous match.
   94              0.000877   if exists('w:paren_hl_on') && w:paren_hl_on
   11              0.000065     silent! call matchdelete(3)
   11              0.000037     let w:paren_hl_on = 0
   94              0.000129   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   94              0.000705   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   94              0.000077   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   94              0.000469   let c_lnum = line('.')
   94              0.000336   let c_col = col('.')
   94              0.000172   let before = 0
                            
   94              0.000421   let text = getline(c_lnum)
   94              0.003764   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   94              0.000369   if empty(matches)
                                let [c_before, c] = ['', '']
   94              0.000110   else
   94              0.000704     let [c_before, c] = matches[1:2]
   94              0.000100   endif
   94              0.002572   let plist = split(&matchpairs, '.\zs[:,]')
   94              0.000549   let i = index(plist, c)
   94              0.000167   if i < 0
                                " not found, in Insert mode try character before the cursor
   86              0.000515     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   74              0.000321       let before = strlen(c_before)
   74              0.000143       let c = c_before
   74              0.000245       let i = index(plist, c)
   86              0.000094     endif
   86              0.000121     if i < 0
                                  " not found, nothing to do
   83              0.000155       return
    3              0.000003     endif
   11              0.000010   endif
                            
                              " Figure out the arguments for searchpairpos().
   11              0.000019   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
   11              0.000008   else
   11              0.000020     let s_flags = 'nbW'
   11              0.000025     let c2 = c
   11              0.000054     let c = plist[i - 1]
   11              0.000009   endif
   11              0.000025   if c == '['
   11              0.000015     let c = '\['
   11              0.000014     let c2 = '\]'
   11              0.000011   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   11              0.000016   if before > 0
    3              0.000026     let has_getcurpos = exists("*getcurpos")
    3              0.000007     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    3              0.000018       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
    3              0.000004     endif
    3              0.000027     call cursor(c_lnum, c_col - before)
   11              0.000005   endif
                            
   11              0.000086   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   11              0.000009   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
   11              0.000062     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   11              0.000016     try
   11              0.019132       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   11              0.000015     endtry
   11              0.000009   endif
                            
                              " Limit the search to lines visible in the window.
   11              0.000051   let stoplinebottom = line('w$')
   11              0.000033   let stoplinetop = line('w0')
   11              0.000022   if i % 2 == 0
                                let stopline = stoplinebottom
   11              0.000011   else
   11              0.000026     let stopline = stoplinetop
   11              0.000007   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   11              0.000043   if mode() == 'i' || mode() == 'R'
   11              0.000072     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   11              0.000007   endif
   11              0.000014   try
   11              0.017726     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   11              0.000015   endtry
                            
   11              0.000029   if before > 0
    3              0.000005     if has_getcurpos
    3              0.000018       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
    3              0.000002     endif
   11              0.000007   endif
                            
                              " If a match is found setup match highlighting.
   11              0.000035   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   11              0.000038     if exists('*matchaddpos')
   11              0.000297       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   11              0.000007     endif
   11              0.000027     let w:paren_hl_on = 1
   11              0.000008   endif

FUNCTION  <SNR>146_Match()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 911
Called 94 times
Total time:   0.032090
 Self time:   0.009818

count  total (s)   self (s)
   94              0.000473   let line   = getline(a:lnum)
   94              0.006210   let offset = match(line, '\C'.a:regex)
   94              0.000471   let col    = offset + 1
                            
   94   0.023140   0.000868   while offset > -1 && s:IsInStringOrComment(a:lnum, col)
                                let offset = match(line, '\C'.a:regex, offset + 1)
                                let col = offset + 1
   94              0.000162   endwhile
                            
   94              0.000179   if offset > -1
   17              0.000044     return col
   77              0.000087   else
   77              0.000268     return 0
                              endif

FUNCTION  gutentags#chdir()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 5
Called 8 times
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
    8              0.000076     if has('nvim')
                                    let chdir = haslocaldir() ? 'lcd' : haslocaldir(-1, 0) ? 'tcd' : 'cd'
    8              0.000009     else
    8              0.000034         let chdir = haslocaldir() ? 'lcd' : 'cd'
    8              0.000008     endif
    8              0.000197     execute chdir a:path

FUNCTION  airline#extensions#gutentags#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/gutentags.vim line 10
Called 94 times
Total time:   0.012963
 Self time:   0.002015

count  total (s)   self (s)
   94   0.012536   0.001588   let msg = gutentags#statusline()
   94              0.000318   return empty(msg) ? '' :  'Gen. ' . msg

FUNCTION  <SNR>136_evaluate_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim line 209
Called 30 times
Total time:   0.005789
 Self time:   0.004390

count  total (s)   self (s)
   30              0.000125   let tabline = a:tabline
   30   0.003382   0.001983   let tabline = substitute(tabline, '%{\([^}]\+\)}', '\=eval(submatch(1))', 'g')
   30              0.000843   let tabline = substitute(tabline, '%#[^#]\+#', '', 'g')
   30              0.000375   let tabline = substitute(tabline, '%(\([^)]\+\)%)', '\1', 'g')
   30              0.000226   let tabline = substitute(tabline, '%\d\+[TX]', '', 'g')
   30              0.000174   let tabline = substitute(tabline, '%=', '', 'g')
   30              0.000179   let tabline = substitute(tabline, '%\d*\*', '', 'g')
   30              0.000219   if has('tablineat')
                                let tabline = substitute(tabline, '%@[^@]\+@', '', 'g')
   30              0.000039   endif
   30              0.000064   return tabline

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 55
Called 94 times
Total time:   0.006923
 Self time:   0.002193

count  total (s)   self (s)
   94   0.006828   0.002098   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/formatters/default.vim line 35
Called 35 times
Total time:   0.001202
 Self time:   0.001202

count  total (s)   self (s)
   35              0.000210   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
   35              0.000445   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
   35              0.000226   if getbufvar(a:bufnr, '&modified') == 1
   28              0.000094     let _ .= s:buf_modified_symbol
   35              0.000064   endif
   35              0.000058   return _

FUNCTION  <SNR>136_get_separator_change_with_end()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim line 76
Called 12 times
Total time:   0.004733
 Self time:   0.000634

count  total (s)   self (s)
   12              0.000053   let sep_change = 0
   12              0.000045   if !empty(a:new_end_group) " Separator between title and the end
    6   0.004344   0.000245     let sep_change += airline#builder#should_change_group(a:new_group, a:new_end_group) ? a:sep_size : a:alt_sep_size
   12              0.000016   endif
   12              0.000034   if !empty(a:old_group) " Separator between the title and the one adjacent
                                let sep_change += airline#builder#should_change_group(a:new_group, a:old_group) ? a:sep_size : a:alt_sep_size
                                if !empty(a:old_end_group) " Remove mis-predicted separator
                                  let sep_change -= airline#builder#should_change_group(a:old_group, a:old_end_group) ? a:sep_size : a:alt_sep_size
                                endif
   12              0.000011   endif
   12              0.000023   return sep_change

FUNCTION  <SNR>132_OnCursorMovedNormalMode()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 681
Called 8 times
Total time:   0.004258
 Self time:   0.002928

count  total (s)   self (s)
    8   0.001600   0.000270   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    8              0.000007   endif
                            
    8              0.002615   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  airline#util#strchars()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 102
Called 30 times
Total time:   0.000309
 Self time:   0.000309

count  total (s)   self (s)
   30              0.000150   if exists('*strchars')
   30              0.000109     return strchars(a:str)
                              else
                                return strlen(substitute(a:str, '.', 'a', 'g'))
                              endif

FUNCTION  <SNR>146_AfterLeadingOperator()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 516
Called 4 times
Total time:   0.000413
 Self time:   0.000209

count  total (s)   self (s)
                              " If the previous line started with a leading operator, use its MSL's level
                              " of indent
    4   0.000274   0.000070   if s:Match(a:pline_info.plnum, s:leading_operator_regex)
                                return indent(s:GetMSL(a:pline_info.plnum))
    4              0.000106   endif
    4              0.000006   return -1

FUNCTION  <SNR>134_remove_illumination()
    Defined: ~/.vim/plugged/vim-illuminate/autoload/illuminate.vim line 114
Called 14 times
Total time:   0.001111
 Self time:   0.001111

count  total (s)   self (s)
   14              0.000188   if has('timers') && exists('s:timer_id') && s:timer_id > -1
    7              0.000062     call timer_stop(s:timer_id)
    7              0.000024     let s:timer_id = -1
   14              0.000018   endif
                            
   14              0.000057   if exists('w:match_id')
   14              0.000027     try
   14              0.000242       call matchdelete(w:match_id)
   11              0.000269     catch /\v(E803|E802)/
   14              0.000041     endtry
   14              0.000015   endif
                            
   14              0.000055   let s:previous_match = ''

FUNCTION  <SNR>146_LeadingOperator()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 410
Called 7 times
Total time:   0.000649
 Self time:   0.000172

count  total (s)   self (s)
                              " If the current line starts with a leading operator, add a level of indent.
    7   0.000580   0.000103   if s:Match(a:cline_info.clnum, s:leading_operator_regex)
                                return indent(s:GetMSL(a:cline_info.clnum)) + a:cline_info.sw
    7              0.000006   endif
    7              0.000009   return -1

FUNCTION  sy#repo#get_diff_git()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy/repo.vim line 142
Called 4 times
Total time:   0.000969
 Self time:   0.000178

count  total (s)   self (s)
    4   0.000130   0.000053   call sy#verbose('get_diff_git()', 'git')
    4              0.000026   let [found_diff, diff] = a:exitval ? [0, []] : [1, a:diff]
    4   0.000806   0.000092   call s:get_diff_end(a:sy, found_diff, 'git', diff)

FUNCTION  <SNR>146_IsInStringOrComment()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 692
Called 47 times
Total time:   0.065114
 Self time:   0.001319

count  total (s)   self (s)
   47   0.065068   0.001273   return s:IsInRubyGroup(s:syng_strcom, a:lnum, a:col)

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 220
Called 30 times
Total time:   0.032815
 Self time:   0.001182

count  total (s)   self (s)
   30              0.000340   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   30   0.032442   0.000809   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>140_CreateCountDict()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim line 5
Called 188 times
Total time:   0.002342
 Self time:   0.002342

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
  188              0.001958     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  <SNR>140_GetCounts()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim line 97
Called 188 times
Total time:   0.011350
 Self time:   0.007044

count  total (s)   self (s)
  188   0.005483   0.003519     if !s:BufferCacheExists(a:buffer)
  188   0.005694   0.003352         return s:CreateCountDict()
                                endif
                            
                                call s:UpdateCacheIfNecessary(a:buffer)
                            
                                return g:ale_buffer_info[a:buffer].count

FUNCTION  delimitMate#JumpOut()
    Defined: ~/.vim/plugged/delimitMate/autoload/delimitMate.vim line 408
Called 1 time
Total time:   0.002916
 Self time:   0.000080

count  total (s)   self (s)
    1   0.002767   0.000050   if s:is_forbidden(a:char)
                                return a:char
    1              0.000001   endif
    1   0.000140   0.000021   let jump = s:is_jump(a:char)
    1              0.000001   if jump == 1
                                " HACK: Instead of <Right>, we remove the char to be jumped over and
                                " insert it again. This will trigger re-indenting via 'indentkeys'.
                                " Ref: https://github.com/Raimondi/delimitMate/issues/168
    1              0.000003     return "\<Del>".a:char
                              elseif jump == 3
                                return s:joinUndo() . "\<Right>" . s:joinUndo() . "\<Right>"
                              elseif jump == 5
                                return "\<Down>\<C-O>I" . s:joinUndo() . "\<Right>"
                              else
                                return a:char
                              endif

FUNCTION  gutentags#make_args()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 108
Called 4 times
Total time:   0.001239
 Self time:   0.001239

count  total (s)   self (s)
    4              0.000015         let l:outcmd = []
   48              0.000119         for cmdarg in a:cmd
                                        " Thanks Vimscript... you can use negative integers for strings
                                        " in the slice notation, but not for indexing characters :(
   44              0.000199             let l:arglen = strlen(cmdarg)
   44              0.000313             if (cmdarg[0] == '"' && cmdarg[l:arglen - 1] == '"') || (cmdarg[0] == "'" && cmdarg[l:arglen - 1] == "'")
   20              0.000097                 call add(l:outcmd, cmdarg[1:-2])
   24              0.000022             else
   24              0.000084                 call add(l:outcmd, cmdarg)
   44              0.000037             endif
   48              0.000051         endfor
    4              0.000011         return l:outcmd

FUNCTION  <SNR>133_update_tags()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 468
Called 4 times
Total time:   0.014357
 Self time:   0.001810

count  total (s)   self (s)
                                " Figure out where to save.
    4              0.000034     let l:buf_gutentags_files = getbufvar(a:bufno, 'gutentags_files')
    4              0.000033     let l:tags_file = l:buf_gutentags_files[a:module]
    4              0.000040     let l:proj_dir = getbufvar(a:bufno, 'gutentags_root')
                            
                                " Check that there's not already an update in progress.
    4   0.000253   0.000138     let l:in_progress_idx = gutentags#find_job_index_by_tags_file(a:module, l:tags_file)
    4              0.000011     if l:in_progress_idx >= 0
                                    if a:queue_mode == 2
                                        let l:needs_queuing = 1
                                        for qu_info in s:update_queue[a:module]
                                            if qu_info[0] == l:tags_file
                                                let l:needs_queuing = 0
                                                break
                                            endif
                                        endfor
                                        if l:needs_queuing
                                            call add(s:update_queue[a:module], [l:tags_file, a:bufno, a:write_mode])
                                        endif
                                        call gutentags#trace("Tag file '" . l:tags_file . "' is already being updated. Queuing it up...")
                                    elseif a:queue_mode == 1
                                        call gutentags#trace("Tag file '" . l:tags_file ."' is already being updated. Skipping...")
                                    elseif a:queue_mode == 0
                                        echom "gutentags: The tags file is already being updated, " ."please try again later."
                                    else
                                        call gutentags#throw("Unknown queue mode: " . a:queue_mode)
                                    endif
                            
                                    " Don't update the tags right now.
                                    return
    4              0.000004     endif
                            
                                " Switch to the project root to make the command line smaller, and make
                                " it possible to get the relative path of the filename to parse if we're
                                " doing an incremental update.
    4              0.000026     let l:prev_cwd = getcwd()
    4   0.000291   0.000142     call gutentags#chdir(fnameescape(l:proj_dir))
    4              0.000006     try
    4   0.012837   0.000811         call call("gutentags#".a:module."#generate",[l:proj_dir, l:tags_file, {   'write_mode': a:write_mode, }])
                                catch /^gutentags\:/
                                    echom "Error while generating ".a:module." file:"
                                    echom v:exception
    4              0.000009     finally
                                    " Restore the current directory...
    4   0.000501   0.000244         call gutentags#chdir(fnameescape(l:prev_cwd))
    4              0.000021     endtry

FUNCTION  <SNR>146_AfterHangingSplat()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 525
Called 4 times
Total time:   0.000228
 Self time:   0.000228

count  total (s)   self (s)
    4              0.000024   let info = a:pline_info
                            
                              " If the previous line ended with the "*" of a splat, add a level of indent
    4              0.000155   if info.pline =~ s:splat_regex
                                return indent(info.plnum) + info.sw
    4              0.000006   endif
    4              0.000007   return -1

FUNCTION  <SNR>114_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 162
Called 9 times
Total time:   0.000198
 Self time:   0.000198

count  total (s)   self (s)
    9              0.000072   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    5              0.000017     return
    4              0.000003   endif
    4              0.000024   unlet! b:airline_whitespace_check
    4              0.000012   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
    4              0.000004   endif
    4              0.000017   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>146_ExtraBrackets()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 849
Called 4 times
Total time:   0.010763
 Self time:   0.002803

count  total (s)   self (s)
    4              0.000040   let opening = {'parentheses': [], 'braces': [], 'brackets': []}
    4              0.000025   let closing = {'parentheses': [], 'braces': [], 'brackets': []}
                            
    4              0.000019   let line = getline(a:lnum)
    4              0.000093   let pos  = match(line, '[][(){}]', 0)
                            
                              " Save any encountered opening brackets, and remove them once a matching
                              " closing one has been found. If a closing bracket shows up that doesn't
                              " close anything, save it for later.
   20              0.000044   while pos != -1
   16   0.008448   0.000488     if !s:IsInStringOrComment(a:lnum, pos + 1)
   16              0.000157       if line[pos] == '('
                                    call add(opening.parentheses, {'type': '(', 'pos': pos})
   16              0.000054       elseif line[pos] == ')'
                                    if empty(opening.parentheses)
                                      call add(closing.parentheses, {'type': ')', 'pos': pos})
                                    else
                                      let opening.parentheses = opening.parentheses[0:-2]
                                    endif
   16              0.000050       elseif line[pos] == '{'
                                    call add(opening.braces, {'type': '{', 'pos': pos})
   16              0.000042       elseif line[pos] == '}'
                                    if empty(opening.braces)
                                      call add(closing.braces, {'type': '}', 'pos': pos})
                                    else
                                      let opening.braces = opening.braces[0:-2]
                                    endif
   16              0.000041       elseif line[pos] == '['
    8              0.000083         call add(opening.brackets, {'type': '[', 'pos': pos})
    8              0.000020       elseif line[pos] == ']'
    8              0.000029         if empty(opening.brackets)
                                      call add(closing.brackets, {'type': ']', 'pos': pos})
    8              0.000008         else
    8              0.000055           let opening.brackets = opening.brackets[0:-2]
    8              0.000008         endif
   16              0.000018       endif
   16              0.000016     endif
                            
   16              0.000305     let pos = match(line, '[][(){}]', pos + 1)
   20              0.000076   endwhile
                            
                              " Find the rightmost brackets, since they're the ones that are important in
                              " both opening and closing cases
    4              0.000021   let rightmost_opening = {'type': '(', 'pos': -1}
    4              0.000019   let rightmost_closing = {'type': ')', 'pos': -1}
                            
    4              0.000025   for opening in opening.parentheses + opening.braces + opening.brackets
                                if opening.pos > rightmost_opening.pos
                                  let rightmost_opening = opening
                                endif
    4              0.000006   endfor
                            
    4              0.000016   for closing in closing.parentheses + closing.braces + closing.brackets
                                if closing.pos > rightmost_closing.pos
                                  let rightmost_closing = closing
                                endif
    4              0.000004   endfor
                            
    4              0.000016   return [rightmost_opening, rightmost_closing]

FUNCTION  gutentags#trace()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 33
Called 52 times
Total time:   0.000502
 Self time:   0.000502

count  total (s)   self (s)
   52              0.000182     if g:gutentags_trace || (a:0 && a:1)
                                    let l:message = "gutentags: " . a:message
                                    echom l:message
   52              0.000052     endif

FUNCTION  gutentags#remove_job_by_data()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 418
Called 4 times
Total time:   0.000950
 Self time:   0.000209

count  total (s)   self (s)
    4   0.000222   0.000099     let l:idx = gutentags#find_job_index_by_data(a:module, a:data)
    4   0.000718   0.000100     call gutentags#remove_job(a:module, l:idx)

FUNCTION  <SNR>146_MultilineStringOrLineComment()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 386
Called 7 times
Total time:   0.013405
 Self time:   0.000379

count  total (s)   self (s)
    7              0.000024   let info = a:cline_info
                            
                              " If we are in a multi-line string or line-comment, don't do anything to it.
    7   0.013312   0.000286   if s:IsInStringOrDocumentation(info.clnum, matchend(info.cline, '^\s*') + 1)
                                return indent(info.clnum)
    7              0.000008   endif
    7              0.000012   return -1

FUNCTION  <SNR>132_ClosePreviewWindowIfNeeded()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 754
Called 2 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
    2              0.000041   let current_buffer_name = bufname('')
                            
                              " We don't want to try to close the preview window in special buffers like
                              " "[Command Line]"; if we do, Vim goes bonkers. Special buffers always start
                              " with '['.
    2              0.000037   if current_buffer_name[ 0 ] == '['
                                return
    2              0.000005   endif
                            
                              " This command does the actual closing of the preview window. If no preview
                              " window is shown, nothing happens.
    2              0.000005   pclose

FUNCTION  gutentags#inprogress()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 622
Called 94 times
Total time:   0.008654
 Self time:   0.006763

count  total (s)   self (s)
                                " Does this buffer have gutentags enabled?
   94              0.000512     if !exists('b:gutentags_files')
                                    return []
   94              0.000088     endif
                            
                                " Find any module that has a job in progress for any of this buffer's
                                " tags files.
   94              0.000291     let l:modules_in_progress = []
  188              0.000872     for [module, tags_file] in items(b:gutentags_files)
   94   0.004622   0.002731         let l:jobidx = gutentags#find_job_index_by_tags_file(module, tags_file)
   94              0.000158         if l:jobidx >= 0
    8              0.000072             call add(l:modules_in_progress, module)
   94              0.000103         endif
  188              0.000208     endfor
   94              0.000185     return l:modules_in_progress

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 190
Called 120 times
Total time:   0.003627
 Self time:   0.003627

count  total (s)   self (s)
  120              0.001820   if has_key(s:contexts, a:winnr)
  120              0.001459     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>146_DeindentingKeyword()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 345
Called 8 times
Total time:   0.007621
 Self time:   0.002487

count  total (s)   self (s)
    8              0.000026   let info = a:cline_info
                            
                              " If we have a deindenting keyword, find its match and indent to its level.
                              " TODO: this is messy
    8   0.001757   0.000146   if s:Match(info.clnum, s:ruby_deindent_keywords)
    1              0.000012     call cursor(info.clnum, 1)
                            
    1              0.001830     if searchpair(s:end_start_regex, s:end_middle_regex, s:end_end_regex, 'bW', s:end_skip_expr) > 0
    1   0.003536   0.000021       let msl  = s:GetMSL(line('.'))
    1              0.000003       let line = getline(line('.'))
                            
    1   0.000027   0.000019       if s:IsAssignment(line, col('.')) && strpart(line, col('.') - 1, 2) !~ 'do'
                                    " assignment to case/begin/etc, on the same line
                                    if g:ruby_indent_assignment_style == 'hanging'
                                      " hanging indent
                                      let ind = virtcol('.') - 1
                                    else
                                      " align with variable
                                      let ind = indent(line('.'))
                                    endif
    1              0.000003       elseif g:ruby_indent_block_style == 'do'
                                    " align to line of the "do", not to the MSL
                                    let ind = indent(line('.'))
    1              0.000005       elseif getline(msl) =~ '=\s*\(#.*\)\=$'
                                    " in the case of assignment to the MSL, align to the starting line,
                                    " not to the MSL
                                    let ind = indent(line('.'))
    1              0.000001       else
                                    " align to the MSL
    1              0.000003         let ind = indent(msl)
    1              0.000001       endif
    1              0.000001     endif
    1              0.000001     return ind
    7              0.000007   endif
                            
    7              0.000010   return -1

FUNCTION  <SNR>146_ClosingBracketOnEmptyLine()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 308
Called 8 times
Total time:   0.000767
 Self time:   0.000767

count  total (s)   self (s)
    8              0.000031   let info = a:cline_info
                            
                              " If we got a closing bracket on an empty line, find its match and indent
                              " according to it.  For parentheses we indent to its column - 1, for the
                              " others we indent to the containing line's MSL's level.  Return -1 if fail.
    8              0.000187   let col = matchend(info.cline, '^\s*[]})]')
                            
    8              0.000041   if col > 0 && !s:IsInStringOrComment(info.clnum, col)
                                call cursor(info.clnum, col)
                                let closing_bracket = info.cline[col - 1]
                                let bracket_pair = strpart('(){}[]', stridx(')}]', closing_bracket) * 2, 2)
                            
                                if searchpair(escape(bracket_pair[0], '\['), '', bracket_pair[1], 'bW', s:skip_expr) > 0
                                  if closing_bracket == ')' && col('.') != col('$') - 1
                                    let ind = virtcol('.') - 1
                                  elseif g:ruby_indent_block_style == 'do'
                                    let ind = indent(line('.'))
                                  else " g:ruby_indent_block_style == 'expression'
                                    let ind = indent(s:GetMSL(line('.')))
                                  endif
                                endif
                            
                                return ind
    8              0.000007   endif
                            
    8              0.000014   return -1

FUNCTION  youcompleteme#CompleteFunc()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 874
Called 32 times
Total time:   0.000724
 Self time:   0.000724

count  total (s)   self (s)
   32              0.000097   if a:findstart
                                " When auto-wrapping is enabled, Vim wraps the current line after the
                                " completion request is sent but before calling this function. The starting
                                " column returned by the server is invalid in that case and must be
                                " recomputed.
   16              0.000071     if s:completion.line != line( '.' )
                                  " Given
                                  "   scb: column where the completion starts before auto-wrapping
                                  "   cb: cursor column before auto-wrapping
                                  "   sca: column where the completion starts after auto-wrapping
                                  "   ca: cursor column after auto-wrapping
                                  " we have
                                  "   ca - sca = cb - scb
                                  "   sca = scb + ca - cb
                                  let s:completion.completion_start_column += col( '.' ) - s:completion.column
   16              0.000018     endif
   16              0.000064     return s:completion.completion_start_column - 1
   16              0.000016   endif
   16              0.000042   return s:completion.completions

FUNCTION  <SNR>140_BufferCacheExists()
    Defined: ~/.vim/plugged/ale/autoload/ale/statusline.vim line 88
Called 188 times
Total time:   0.001964
 Self time:   0.001964

count  total (s)   self (s)
  188              0.001456     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
  188              0.000333         return 0
                                endif
                            
                                return 1

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 121
Called 94 times
Total time:   0.000511
 Self time:   0.000511

count  total (s)   self (s)
   94              0.000438   return exists('*lawrencium#statusline')

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 67
Called 760 times
Total time:   0.137443
 Self time:   0.075108

count  total (s)   self (s)
  760              0.013329   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  760              0.003219   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  760              0.000700   else
  760   0.040894   0.012541     let fg = s:get_syn(a:group, 'fg')
  760   0.037123   0.011400     let bg = s:get_syn(a:group, 'bg')
  760              0.004990     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  760              0.000960     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
  760              0.000647     else
  760   0.021366   0.013107       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  760              0.000656     endif
  760              0.000577   endif
  760              0.003591   let s:hl_groups[a:group] = res
  760              0.000988   return res

FUNCTION  <SNR>132_AllowedToCompleteInCurrentBuffer()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 457
Called 118 times
Total time:   0.016904
 Self time:   0.003757

count  total (s)   self (s)
  118   0.016792   0.003645   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  <SNR>154_untracked_output()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/async.vim line 11
Called 7 times
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
    7              0.000116   if a:buf =~? ('^'. a:dict.cfg['untracked_mark'])
    7              0.000085     let a:dict.cfg.untracked[a:dict.file] = get(g:, 'airline#extensions#branch#notexists', g:airline_symbols.notexists)
                              else
                                let a:dict.cfg.untracked[a:dict.file] = ''
    7              0.000009   endif

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 22
Called 282 times
Total time:   0.013612
 Self time:   0.009460

count  total (s)   self (s)
  282   0.009523   0.005371   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return ''.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').''
                                endif
  282              0.000223   else
  282              0.000507     return a:text
                              endif

FUNCTION  279()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 8
Called 6 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    6              0.000041   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>132_Pyeval()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 68
Called 193 times
Total time:   0.044032
 Self time:   0.044032

count  total (s)   self (s)
  193              0.000559   if s:using_python3
  193              0.043133     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  <SNR>49_MRU_AddFile()
    Defined: ~/.vim/plugged/mru/plugin/mru.vim line 166
Called 4 times
Total time:   0.061782
 Self time:   0.002344

count  total (s)   self (s)
    4              0.000032     if s:mru_list_locked
                                    " MRU list is currently locked
                                    return
    4              0.000011     endif
                            
                                " Get the full path to the filename
    4              0.000227     let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
    4              0.000021     if fname == ''
                                    return
    4              0.000006     endif
                            
                                " Skip temporary buffers with buftype set. The buftype is set for buffers
                                " used by plugins.
    4              0.000026     if &buftype != ''
                                    return
    4              0.000004     endif
                            
    4              0.000012     if g:MRU_Include_Files != ''
                                    " If MRU_Include_Files is set, include only files matching the
                                    " specified pattern
                                    if fname !~# g:MRU_Include_Files
                                        return
                                    endif
    4              0.000005     endif
                            
    4              0.000011     if g:MRU_Exclude_Files != ''
                                    " Do not add files matching the pattern specified in the
                                    " MRU_Exclude_Files to the MRU list
                                    if fname =~# g:MRU_Exclude_Files
                                        return
                                    endif
    4              0.000004     endif
                            
                                " If the filename is not already present in the MRU list and is not
                                " readable then ignore it
    4              0.000041     let idx = index(s:MRU_files, fname)
    4              0.000011     if idx == -1
                                    if !filereadable(fname)
                                        " File is not readable and is not in the MRU list
                                        return
                                    endif
    4              0.000002     endif
                            
                                " Load the latest MRU file list
    4   0.014891   0.000164     call s:MRU_LoadList()
                            
                                " Remove the new file name from the existing MRU list (if already present)
    4              0.000442     call filter(s:MRU_files, 'v:val !=# fname')
                            
                                " Add the new file list to the beginning of the updated old file list
    4              0.000019     call insert(s:MRU_files, fname, 0)
                            
                                " Trim the list
    4              0.000016     if len(s:MRU_files) > g:MRU_Max_Entries
                                    call remove(s:MRU_files, g:MRU_Max_Entries, -1)
    4              0.000003     endif
                            
                                " Save the updated MRU list
    4   0.034241   0.000294     call s:MRU_SaveList()
                            
                                " Refresh the MRU menu
    4   0.011127   0.000363     call s:MRU_Refresh_Menu()
                            
                                " If the MRU window is open, update the displayed MRU list
    4              0.000010     let bname = '__MRU_Files__'
    4              0.000346     let winnum = bufwinnr(bname)
    4              0.000012     if winnum != -1
                                    let cur_winnr = winnr()
                                    call s:MRU_Open_Window()
                                    if winnr() != cur_winnr
                                        exe cur_winnr . 'wincmd w'
                                    endif
    4              0.000005     endif

FUNCTION  airline#extensions#tabline#new_builder()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline.vim line 188
Called 6 times
Total time:   0.001136
 Self time:   0.000559

count  total (s)   self (s)
    6              0.000135   let builder_context = { 'active'        : 1, 'tabline'       : 1, 'right_sep'     : get(g:, 'airline#extensions#tabline#right_sep'    , g:airline_right_sep), 'right_alt_sep' : get(g:, 'airline#extensions#tabline#right_alt_sep', g:airline_right_alt_sep), }
    6              0.000023   if get(g:, 'airline_powerline_fonts', 0)
                                let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , g:airline_left_sep)
                                let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , g:airline_left_alt_sep)
    6              0.000007   else
    6              0.000035     let builder_context.left_sep     = get(g:, 'airline#extensions#tabline#left_sep'     , ' ')
    6              0.000041     let builder_context.left_alt_sep = get(g:, 'airline#extensions#tabline#left_alt_sep' , '|')
    6              0.000005   endif
                            
    6   0.000811   0.000234   return airline#extensions#tabline#builder#new(builder_context)

FUNCTION  280()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 12
Called 6 times
Total time:   0.000229
 Self time:   0.000178

count  total (s)   self (s)
    6              0.000071   let spc = empty(a:contents) ? '' : g:airline_symbols.space
    6   0.000150   0.000099   call self.add_section(a:group, spc.a:contents.spc)

FUNCTION  281()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 17
Called 18 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
   18              0.000148   call add(self._sections, [a:group, a:contents])

FUNCTION  283()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 25
Called 6 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    6              0.000046   call insert(self._sections, [a:group, a:contents], a:position)

FUNCTION  286()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 62
Called 12 times
Total time:   0.064205
 Self time:   0.011009

count  total (s)   self (s)
   12              0.000043   let side = 1
   12              0.000019   let line = ''
   12              0.000020   let i = 0
   12              0.000050   let length = len(self._sections)
   12              0.000021   let split = 0
   12              0.000023   let is_empty = 0
   12              0.000025   let prev_group = ''
                            
   66              0.000161   while i < length
   54              0.000213     let section = self._sections[i]
   54              0.000151     let group = section[0]
   54              0.000144     let contents = section[1]
   54              0.000113     let pgroup = prev_group
   54   0.003227   0.001451     let prev_group = airline#builder#get_prev_group(self._sections, i)
   54              0.000187     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   54              0.000231     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
   54              0.000199     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
   54              0.000047     endif
   54              0.000093     if is_empty
                                  let prev_group = pgroup
   54              0.000046     endif
   54   0.002526   0.001426     let is_empty = s:section_is_empty(self, contents)
                            
   54              0.000071     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   54              0.000045     endif
                            
   54              0.000092     if group == ''
                                  let line .= contents
   54              0.000090     elseif group == '|'
   12              0.000018       let side = 0
   12              0.000033       let line .= contents
   12              0.000018       let split = 1
   42              0.000033     else
   42              0.000072       if prev_group == ''
   12              0.000052         let line .= '%#'.group.'#'
   30              0.000040       elseif split
   12              0.000018         if !is_empty
   12   0.014847   0.000386           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
   12              0.000011         endif
   12              0.000022         let split = 0
   18              0.000013       else
   18              0.000027         if !is_empty
   18   0.033443   0.000444           let line .= s:get_seperator(self, prev_group, group, side)
   18              0.000024         endif
   42              0.000038       endif
   42   0.004159   0.001299       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   54              0.000061     endif
                            
   54              0.000230     let i = i + 1
   66              0.000163   endwhile
                            
   12              0.000028   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
   12              0.000011   endif
   12              0.000030   return line

FUNCTION  287()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim line 18
Called 6 times
Total time:   0.000212
 Self time:   0.000174

count  total (s)   self (s)
    6              0.000025   let self._first_title = a:first " lowest index
    6              0.000016   let self._last_title = a:last " highest index
    6              0.000019   let self._left_title = a:current " next index to add on the left
    6              0.000020   let self._right_title = a:current + 1 " next index to add on the right
    6   0.000106   0.000068   let self._left_position = self.get_position() " left end of titles
    6              0.000017   let self._right_position = self._left_position " right end of the titles

FUNCTION  288()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tabline/builder.vim line 41
Called 6 times
Total time:   0.005839
 Self time:   0.000605

count  total (s)   self (s)
    6   0.001517   0.000068   let title = self.get_title(a:index)
    6   0.003924   0.000191   let title_size = s:tabline_evaluated_length(title) + a:sep_size
    6              0.000016   if a:force || self._remaining_space >= title_size
    6              0.000012     let pos = a:pos
    6              0.000038     if has_key(self, "get_pretitle")
                                  call self.insert_raw(self.get_pretitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
    6              0.000005     endif
                            
    6   0.000120   0.000068     call self.insert_section(a:group, title, pos)
    6              0.000018     let self._right_position += 1
    6              0.000011     let pos += 1
                            
    6              0.000017     if has_key(self, "get_posttitle")
                                  call self.insert_raw(self.get_posttitle(a:index), pos)
                                  let self._right_position += 1
                                  let pos += 1
    6              0.000007     endif
                            
    6              0.000017     let self._remaining_space -= title_size
    6              0.000008     return 1
                              endif
                              return 0

FUNCTION  <SNR>146_PrevNonBlankNonString()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 719
Called 11 times
Total time:   0.028727
 Self time:   0.001201

count  total (s)   self (s)
   11              0.000042   let in_block = 0
   11              0.000056   let lnum = prevnonblank(a:lnum)
   11              0.000031   while lnum > 0
                                " Go in and out of blocks comments as necessary.
                                " If the line isn't empty (with opt. comment) or in a string, end search.
   11              0.000045     let line = getline(lnum)
   11              0.000093     if line =~ '^=begin'
                                  if in_block
                                    let in_block = 0
                                  else
                                    break
                                  endif
   11              0.000085     elseif !in_block && line =~ '^=end'
                                  let in_block = 1
   11   0.028063   0.000537     elseif !in_block && line !~ '^\s*#.*$' && !(s:IsInStringOrComment(lnum, 1) && s:IsInStringOrComment(lnum, strlen(line)))
   11              0.000043       break
                                endif
                                let lnum = prevnonblank(lnum - 1)
   11              0.000034   endwhile
   11              0.000029   return lnum

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 62
Called 94 times
Total time:   0.032297
 Self time:   0.019628

count  total (s)   self (s)
   94              0.000460   if !get(w:, 'airline_active', 0)
                                return ''
   94              0.000067   endif
                              " Cache values, so that it isn't called too often
   94   0.002489   0.002066   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
   94              0.000068   endif
   94   0.009563   0.002225   let hunks = airline#extensions#hunks#get_raw_hunks()
   94              0.000142   let string = ''
   94   0.002161   0.001579   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
   94              0.000213   if !empty(hunks)
  376              0.000792     for i in [0, 1, 2]
  282   0.008412   0.005067       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  282              0.002327         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  282              0.000260       endif
  376              0.000395     endfor
   94              0.000077   endif
   94              0.000262   let b:airline_hunks = string
   94              0.000256   let b:airline_changenr = b:changedtick
   94   0.002546   0.001565   let s:airline_winwidth = airline#util#winwidth()
   94              0.000139   return string

FUNCTION  <SNR>127_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 158
Called 18 times
Total time:   0.032999
 Self time:   0.001926

count  total (s)   self (s)
   18   0.011827   0.001307   if airline#builder#should_change_group(a:prev_group, a:group)
   18   0.021151   0.000598     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>134_match_word()
    Defined: ~/.vim/plugged/vim-illuminate/autoload/illuminate.vim line 93
Called 5 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    5              0.000016   if (a:word ==# '\<\>')
    2              0.000003     return
    3              0.000003   endif
    3              0.000006   if g:Illuminate_highlightUnderCursor
    3              0.000070     let w:match_id = matchadd('illuminatedWord', '\V' . a:word, s:priority)
                              else
                                let w:match_id = matchadd('illuminatedWord', '\V\(\k\*\%#\k\*\)\@\!\&' . a:word, s:priority)
    3              0.000003   endif

FUNCTION  <SNR>74_StartHL()
    Defined: ~/.vim/plugged/vim-cool/plugin/cool.vim line 28
Called 8 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    8              0.000046     if !v:hlsearch || mode() isnot 'n'
    8              0.000018         return
                                endif
                                let [pos, rpos] = [winsaveview(), getpos('.')]
                                silent! exe "keepjumps go".(line2byte('.')+col('.')-(v:searchforward ? 2 : 0))
                                try
                                    silent keepjumps norm! n
                                    if getpos('.') != rpos
                                        throw 0
                                    endif
                                catch /^\%(0$\|Vim\%(\w\|:Interrupt$\)\@!\)/
                                    call <SID>StopHL()
                                    return
                                finally
                                    call winrestview(pos)
                                endtry
                                if !get(g:,'CoolTotalMatches') || !exists('*reltimestr')
                                    return
                                endif
                                exe "silent! norm! :let g:cool_char=nr2char(screenchar(screenrow(),1))\<cr>"
                                let cool_char = remove(g:,'cool_char')
                                if cool_char !~ '[/?]'
                                    return
                                endif
                                let [f, ws, now, noOf] = [0, &wrapscan, reltime(), [0,0]]
                                set nowrapscan
                                try
                                    while f < 2
                                        if reltimestr(reltime(now))[:-6] =~ '[1-9]'
                                            " time >= 100ms
                                            return
                                        endif
                                        let noOf[v:searchforward ? f : !f] += 1
                                        try
                                            silent exe "keepjumps norm! ".(f ? 'n' : 'N')
                                        catch /^Vim[^)]\+):E38[45]\D/
                                            call setpos('.',rpos)
                                            let f += 1
                                        endtry
                                    endwhile
                                finally
                                    call winrestview(pos)
                                    let &wrapscan = ws
                                endtry
                                redraw|echo cool_char.@/ 'match' noOf[0] 'of' noOf[0] + noOf[1] - 1

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 57
Called 188 times
Total time:   0.001884
 Self time:   0.001884

count  total (s)   self (s)
  188              0.000649   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  188              0.000156   endif
  188              0.000672   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>146_IsAssignment()
    Defined: ~/.vim/plugged/vim-ruby/indent/ruby.vim line 714
Called 5 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    5              0.000046   return strpart(a:str, 0, a:pos - 1) =~ '=\s*$'

FUNCTION  <SNR>45_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim line 60
Called 8 times
Total time:   0.000489
 Self time:   0.000363

count  total (s)   self (s)
    8              0.000083   if winnr() != s:active_winnr
                                call s:on_window_changed()
    8              0.000014   endif
    8   0.000325   0.000199   call airline#update_tabline()

FUNCTION  <SNR>132_OnBlankLine()
    Defined: ~/.vim/plugged/YouCompleteMe/autoload/youcompleteme.vim line 813
Called 40 times
Total time:   0.005350
 Self time:   0.000664

count  total (s)   self (s)
   40   0.005309   0.000623   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  gutentags#build_default_job_options()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim line 605
Called 4 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    4              0.000051         let l:job_opts = {'exit_cb': 'gutentags#'.a:module.'#on_job_exit','out_cb': 'gutentags#default_io_cb','err_cb': 'gutentags#default_io_cb','stoponexit': 'term'}
    4              0.000010         return l:job_opts

FUNCTION  <SNR>60_MoveLineUp()
    Defined: ~/.vim/plugged/vim-move/plugin/move.vim line 127
Called 2 times
Total time:   0.036948
 Self time:   0.000330

count  total (s)   self (s)
    2              0.000029     let l:distance = a:count + 1
                            
    2              0.000007     if v:count > 0
                                    let l:distance = l:distance + v:count - 1
    2              0.000004     endif
                            
    2              0.000015     if (line('.') - l:distance) < 0
                                    execute 'silent move 0'
                                    if (g:move_auto_indent == 1)
                                        normal! ==
                                    endif
                                    return
    2              0.000002     endif
                            
    2              0.000061     execute 'silent m-' . l:distance
                            
    2              0.000007     if (g:move_auto_indent == 1)
    2   0.036779   0.000161         normal! ==
    2              0.000002     endif

FUNCTION  airline#extensions#ale#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim line 107
Called 94 times
Total time:   0.029977
 Self time:   0.002064

count  total (s)   self (s)
   94   0.029893   0.001980   return airline#extensions#ale#get('warning')

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 232
Called 6 times
Total time:   0.000317
 Self time:   0.000317

count  total (s)   self (s)
    6              0.000133   let builder = copy(s:prototype)
    6              0.000027   let builder._context = a:context
    6              0.000016   let builder._sections = []
                            
    6              0.000104   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    6              0.000015   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   40   0.355823   0.018827  <SNR>132_OnTextChangedInsertMode()
  120   0.246955   0.020560  airline#check_mode()
   38   0.238692   0.121297  <SNR>132_InvokeCompletion()
    7   0.220646   0.035627  airline#highlighter#highlight()
    7   0.168528   0.077405  AutoSave()
  392   0.139493   0.043624  airline#highlighter#exec()
  760   0.137443   0.075108  airline#highlighter#get_highlight()
  160   0.130209   0.014305  <SNR>124_exec_separator()
    8   0.110055   0.006176  GetRubyIndent()
   29   0.108546   0.002748  airline#extensions#tabline#get()
   29   0.105798   0.003744  airline#extensions#tabline#buffers#get()
   94   0.093883   0.008259  airline#extensions#branch#get_head()
    1   0.090109             <SNR>156_DefRuby()
    6   0.083706   0.003303  289()
   94   0.080464   0.006032  airline#extensions#branch#head()
   57   0.078236             <SNR>146_IsInRubyGroup()
   40   0.070896   0.001423  <SNR>132_InsideCommentOrStringAndShouldStop()
   40   0.069473             <SNR>132_InsideCommentOrString()
   47   0.065114   0.001319  <SNR>146_IsInStringOrComment()
   12   0.064205   0.011009  286()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   38   0.238692   0.121297  <SNR>132_InvokeCompletion()
    1              0.090109  <SNR>156_DefRuby()
   57              0.078236  <SNR>146_IsInRubyGroup()
    7   0.168528   0.077405  AutoSave()
  760   0.137443   0.075108  airline#highlighter#get_highlight()
   40              0.069473  <SNR>132_InsideCommentOrString()
   94              0.054811  <SNR>91_Highlight_Matching_Pair()
 1520              0.054076  <SNR>124_get_syn()
  193              0.044032  <SNR>132_Pyeval()
  392   0.139493   0.043624  airline#highlighter#exec()
    7   0.220646   0.035627  airline#highlighter#highlight()
    4              0.033947  <SNR>49_MRU_SaveList()
   86              0.029042  UltiSnips#TrackChange()
  188   0.053455   0.027043  airline#extensions#ale#get()
  120   0.246955   0.020560  airline#check_mode()
   94   0.032297   0.019628  airline#extensions#hunks#get_hunks()
   40   0.355823   0.018827  <SNR>132_OnTextChangedInsertMode()
   94   0.029992   0.018565  airline#extensions#whitespace#check()
    8   0.020953   0.017899  <SNR>49_MRU_add_files_to_menu()
   94   0.030524   0.016575  <SNR>111_update_untracked()

